library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.NUMERIC_STD.ALL;

entity fetch_connector is
  port (
    -- System clock/reset
    clk   : in  std_logic;
    reset : in  std_logic;

    -- AXI4 outward (to BD or testbench)
    M_AXI_ACLK    : out std_logic;
    M_AXI_ARESETN : out std_logic;

    -- AXI Read Address
    M_AXI_ARID    : out std_logic_vector(0 downto 0);
    M_AXI_ARADDR  : out std_logic_vector(31 downto 0);
    M_AXI_ARLEN   : out std_logic_vector(7 downto 0);
    M_AXI_ARSIZE  : out std_logic_vector(2 downto 0);
    M_AXI_ARBURST : out std_logic_vector(1 downto 0);
    M_AXI_ARLOCK  : out std_logic;
    M_AXI_ARCACHE : out std_logic_vector(3 downto 0);
    M_AXI_ARPROT  : out std_logic_vector(2 downto 0);
    M_AXI_ARQOS   : out std_logic_vector(3 downto 0);
    M_AXI_ARUSER  : out std_logic_vector(0 downto 0);
    M_AXI_ARVALID : out std_logic;
    M_AXI_ARREADY : in  std_logic;

    -- AXI Read Data
    M_AXI_RID     : in  std_logic_vector(0 downto 0);
    M_AXI_RDATA   : in  std_logic_vector(31 downto 0);
    M_AXI_RRESP   : in  std_logic_vector(1 downto 0);
    M_AXI_RLAST   : in  std_logic;
    M_AXI_RUSER   : in  std_logic_vector(0 downto 0);
    M_AXI_RVALID  : in  std_logic;
    M_AXI_RREADY  : out std_logic;

    -- AXI Write passthrough (unused by IF but kept for top/BD cleanliness)
    M_AXI_AWID    : out std_logic_vector(0 downto 0);
    M_AXI_AWADDR  : out std_logic_vector(31 downto 0);
    M_AXI_AWLEN   : out std_logic_vector(7 downto 0);
    M_AXI_AWSIZE  : out std_logic_vector(2 downto 0);
    M_AXI_AWBURST : out std_logic_vector(1 downto 0);
    M_AXI_AWLOCK  : out std_logic;
    M_AXI_AWCACHE : out std_logic_vector(3 downto 0);
    M_AXI_AWPROT  : out std_logic_vector(2 downto 0);
    M_AXI_AWQOS   : out std_logic_vector(3 downto 0);
    M_AXI_AWUSER  : out std_logic_vector(0 downto 0);
    M_AXI_AWVALID : out std_logic;
    M_AXI_AWREADY : in  std_logic;
    M_AXI_WDATA   : out std_logic_vector(31 downto 0);
    M_AXI_WSTRB   : out std_logic_vector(3 downto 0);
    M_AXI_WLAST   : out std_logic;
    M_AXI_WUSER   : out std_logic_vector(0 downto 0);
    M_AXI_WVALID  : out std_logic;
    M_AXI_WREADY  : in  std_logic;
    M_AXI_BID     : in  std_logic_vector(0 downto 0);
    M_AXI_BRESP   : in  std_logic_vector(1 downto 0);
    M_AXI_BUSER   : in  std_logic_vector(0 downto 0);
    M_AXI_BVALID  : in  std_logic;
    M_AXI_BREADY  : out std_logic;

    -- Observability from the core
    pc_q        : out std_logic_vector(31 downto 0);
    alu_y       : out std_logic_vector(31 downto 0);
    regA_q      : out std_logic_vector(31 downto 0);
    regB_q      : out std_logic_vector(31 downto 0);
    eyu_illegal : out std_logic
  );
end fetch_connector;

architecture Behavioral of fetch_connector is

  -- Simple 2-state sequencer: issue read, wait for completion
  type eyu_seq_state_t is (EYU_FETCH, EYU_WAIT);
  signal eyu_state       : eyu_seq_state_t := EYU_FETCH;
  signal eyu_start_read  : std_logic := '0';

  -- AXI master (entity_name) handshake/result
  signal eyu_fetch_done  : std_logic := '0';
  signal eyu_fetch_error : std_logic := '0';
  signal eyu_fetch_data  : std_logic_vector(0 to 31) := (others => '0');

  -- Instruction mapping 0..31 -> 31:0 for the decoder
  signal eyu_instr_c     : std_logic_vector(31 downto 0) := (others => '0');
  signal eyu_instr_r     : std_logic_vector(31 downto 0) := (others => '0');

  -- Local view of PC from the core
  signal eyu_pc_q_s      : std_logic_vector(31 downto 0);

  -- Active-low AXI reset as a SIGNAL (required in a port map)
  signal eyu_rstn_axi    : std_logic;

  -- One-cycle execute enable for the connector (gates PCie/PCle inside connector)
  signal eyu_exec_en     : std_logic := '0';

begin
  --------------------------------------------------------------------------
  -- AXI clock/reset outward
  --------------------------------------------------------------------------
  M_AXI_ACLK    <= clk;
  eyu_rstn_axi  <= not reset;
  M_AXI_ARESETN <= eyu_rstn_axi;

  --------------------------------------------------------------------------
  -- Map fetched vector 0..31 into 31:0 instruction word
  --------------------------------------------------------------------------
  gen_map : for i in 0 to 31 generate
    eyu_instr_c(i) <= eyu_fetch_data(i);
  end generate;

  --------------------------------------------------------------------------
  -- Core connector (decoder + datapath)
  -- NOTE: this expects connector to have: exec_en : in std_logic
  -- and to gate PCie/PCle internally with exec_en.
  --------------------------------------------------------------------------
  U_CORE: entity work.connector
    port map (
      clk         => clk,
      reset       => reset,
      eyu         => eyu_instr_r,
      exec_en     => eyu_exec_en,   -- <<< one-cycle EXECUTE enable
      pc_q        => eyu_pc_q_s,
      alu_y       => alu_y,
      regA_q      => regA_q,
      regB_q      => regB_q,
      eyu_illegal => eyu_illegal
    );

  pc_q <= eyu_pc_q_s;

  --------------------------------------------------------------------------
  -- AXI instruction fetch master (entity_name)
  --------------------------------------------------------------------------
  U_FETCH: entity work.entity_name
    generic map (
      C_M_AXI_ID_WIDTH     => 1,
      C_M_AXI_ADDR_WIDTH   => 32,
      C_M_AXI_DATA_WIDTH   => 32,
      C_M_AXI_AWUSER_WIDTH => 1,
      C_M_AXI_ARUSER_WIDTH => 1,
      C_M_AXI_WUSER_WIDTH  => 1,
      C_M_AXI_RUSER_WIDTH  => 1,
      C_M_AXI_BUSER_WIDTH  => 1
    )
    port map (
      -- control
      Start_read    => eyu_start_read,
      Read_address  => eyu_pc_q_s,      -- fetch at current PC
      Read_Done     => eyu_fetch_done,
      Read_Data     => eyu_fetch_data,  -- (0..31) ascending range
      Error         => eyu_fetch_error,

      -- AXI clock/reset
      M_AXI_ACLK    => clk,
      M_AXI_ARESETN => eyu_rstn_axi,

      -- AXI Read Address
      M_AXI_ARID    => M_AXI_ARID,
      M_AXI_ARADDR  => M_AXI_ARADDR,
      M_AXI_ARLEN   => M_AXI_ARLEN,
      M_AXI_ARSIZE  => M_AXI_ARSIZE,
      M_AXI_ARBURST => M_AXI_ARBURST,
      M_AXI_ARLOCK  => M_AXI_ARLOCK,
      M_AXI_ARCACHE => M_AXI_ARCACHE,
      M_AXI_ARPROT  => M_AXI_ARPROT,
      M_AXI_ARQOS   => M_AXI_ARQOS,
      M_AXI_ARUSER  => M_AXI_ARUSER,
      M_AXI_ARVALID => M_AXI_ARVALID,
      M_AXI_ARREADY => M_AXI_ARREADY,

      -- AXI Read Data
      M_AXI_RID     => M_AXI_RID,
      M_AXI_RDATA   => M_AXI_RDATA,
      M_AXI_RRESP   => M_AXI_RRESP,
      M_AXI_RLAST   => M_AXI_RLAST,
      M_AXI_RUSER   => M_AXI_RUSER,
      M_AXI_RVALID  => M_AXI_RVALID,
      M_AXI_RREADY  => M_AXI_RREADY,

      -- AXI Write passthrough (unused by IF)
      M_AXI_AWID    => M_AXI_AWID,   M_AXI_AWADDR => M_AXI_AWADDR,
      M_AXI_AWLEN   => M_AXI_AWLEN,  M_AXI_AWSIZE => M_AXI_AWSIZE,
      M_AXI_AWBURST => M_AXI_AWBURST,M_AXI_AWLOCK => M_AXI_AWLOCK,
      M_AXI_AWCACHE => M_AXI_AWCACHE,M_AXI_AWPROT => M_AXI_AWPROT,
      M_AXI_AWQOS   => M_AXI_AWQOS,  M_AXI_AWUSER => M_AXI_AWUSER,
      M_AXI_AWVALID => M_AXI_AWVALID,M_AXI_AWREADY=> M_AXI_AWREADY,
      M_AXI_WDATA   => M_AXI_WDATA,  M_AXI_WSTRB  => M_AXI_WSTRB,
      M_AXI_WLAST   => M_AXI_WLAST,  M_AXI_WUSER  => M_AXI_WUSER,
      M_AXI_WVALID  => M_AXI_WVALID, M_AXI_WREADY => M_AXI_WREADY,
      M_AXI_BID     => M_AXI_BID,    M_AXI_BRESP  => M_AXI_BRESP,
      M_AXI_BUSER   => M_AXI_BUSER,  M_AXI_BVALID => M_AXI_BVALID,
      M_AXI_BREADY  => M_AXI_BREADY
    );

  --------------------------------------------------------------------------
  -- Sequencer: FETCH â†’ WAIT, pulse EXECUTE when a fetch completes
  --------------------------------------------------------------------------
  process(clk)
  begin
    if rising_edge(clk) then
      if reset = '1' then
        eyu_state      <= EYU_FETCH;
        eyu_start_read <= '0';
        eyu_instr_r    <= (others => '0');
        eyu_exec_en    <= '0';
      else
        eyu_exec_en    <= '0';         -- default low each cycle
        case eyu_state is
          when EYU_FETCH =>
            eyu_start_read <= '1';     -- 1-cycle request
            eyu_state      <= EYU_WAIT;

          when EYU_WAIT  =>
            eyu_start_read <= '0';
            if (eyu_fetch_done = '1') or (eyu_fetch_error = '1') then
              eyu_instr_r <= eyu_instr_c;  -- present word to decoder
              eyu_exec_en <= '1';          -- allow connector to update PC/regs
              eyu_state   <= EYU_FETCH;    -- next fetch
            end if;
        end case;
      end if;
    end if;
  end process;

end Behavioral;
