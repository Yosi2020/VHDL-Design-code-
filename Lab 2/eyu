library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.NUMERIC_STD.ALL;

entity fetch_connector is
  port (
    clk   : in  std_logic;
    reset : in  std_logic;

    -- AXI4 outward
    M_AXI_ACLK    : out std_logic;
    M_AXI_ARESETN : out std_logic;

    -- AXI Read Address
    M_AXI_ARID    : out std_logic_vector(0 downto 0);
    M_AXI_ARADDR  : out std_logic_vector(31 downto 0);
    M_AXI_ARLEN   : out std_logic_vector(7 downto 0);
    M_AXI_ARSIZE  : out std_logic_vector(2 downto 0);
    M_AXI_ARBURST : out std_logic_vector(1 downto 0);
    M_AXI_ARLOCK  : out std_logic;
    M_AXI_ARCACHE : out std_logic_vector(3 downto 0);
    M_AXI_ARPROT  : out std_logic_vector(2 downto 0);
    M_AXI_ARQOS   : out std_logic_vector(3 downto 0);
    M_AXI_ARUSER  : out std_logic_vector(0 downto 0);
    M_AXI_ARVALID : out std_logic;
    M_AXI_ARREADY : in  std_logic;

    -- AXI Read Data
    M_AXI_RID     : in  std_logic_vector(0 downto 0);
    M_AXI_RDATA   : in  std_logic_vector(31 downto 0);
    M_AXI_RRESP   : in  std_logic_vector(1 downto 0);
    M_AXI_RLAST   : in  std_logic;
    M_AXI_RUSER   : in  std_logic_vector(0 downto 0);
    M_AXI_RVALID  : in  std_logic;
    M_AXI_RREADY  : out std_logic;

    -- AXI Write channels (exposed; unused by IF)
    M_AXI_AWID    : out std_logic_vector(0 downto 0);
    M_AXI_AWADDR  : out std_logic_vector(31 downto 0);
    M_AXI_AWLEN   : out std_logic_vector(7 downto 0);
    M_AXI_AWSIZE  : out std_logic_vector(2 downto 0);
    M_AXI_AWBURST : out std_logic_vector(1 downto 0);
    M_AXI_AWLOCK  : out std_logic;
    M_AXI_AWCACHE : out std_logic_vector(3 downto 0);
    M_AXI_AWPROT  : out std_logic_vector(2 downto 0);
    M_AXI_AWQOS   : out std_logic_vector(3 downto 0);
    M_AXI_AWUSER  : out std_logic_vector(0 downto 0);
    M_AXI_AWVALID : out std_logic;
    M_AXI_AWREADY : in  std_logic;
    M_AXI_WDATA   : out std_logic_vector(31 downto 0);
    M_AXI_WSTRB   : out std_logic_vector(3 downto 0);
    M_AXI_WLAST   : out std_logic;
    M_AXI_WUSER   : out std_logic_vector(0 downto 0);
    M_AXI_WVALID  : out std_logic;
    M_AXI_WREADY  : in  std_logic;
    M_AXI_BID     : in  std_logic_vector(0 downto 0);
    M_AXI_BRESP   : in  std_logic_vector(1 downto 0);
    M_AXI_BUSER   : in  std_logic_vector(0 downto 0);
    M_AXI_BVALID  : in  std_logic;
    M_AXI_BREADY  : out std_logic;

    -- Observability from your core
    pc_q        : out std_logic_vector(31 downto 0);
    alu_y       : out std_logic_vector(31 downto 0);
    regA_q      : out std_logic_vector(31 downto 0);
    regB_q      : out std_logic_vector(31 downto 0);
    eyu_illegal : out std_logic
  );
end fetch_connector;

architecture Behavioral of fetch_connector is
  type s_state is (S_FETCH, S_WAIT);
  signal st            : s_state := S_FETCH;
  signal eyu_start_read: std_logic := '0';
  signal eyu_axi_resetn : std_logic;

  signal fetch_done  : std_logic := '0';
  signal fetch_error : std_logic := '0';
  signal fetch_data  : std_logic_vector(0 to 31) := (others=>'0');

  signal instr_c : std_logic_vector(31 downto 0) := (others=>'0');
  signal instr_r : std_logic_vector(31 downto 0) := (others=>'0');

  signal pc_q_s  : std_logic_vector(31 downto 0);
  signal rstn_axi : std_logic;
begin
  -- pass-through AXI clock/reset
  M_AXI_ACLK    <= clk;
  rstn_axi <= not reset;
  M_AXI_ARESETN <= rstn_axi;

  -- map 0..31 vector to 31:0
  gen_map: for i in 0 to 31 generate
    instr_c(i) <= fetch_data(i);
  end generate;

  -- your existing connector (decoder + datapath)
  U_CORE: entity work.connector
    port map (
      clk         => clk,
      reset       => reset,
      eyu         => instr_r,
      pc_q        => pc_q_s,
      alu_y       => alu_y,
      regA_q      => regA_q,
      regB_q      => regB_q,
      eyu_illegal => eyu_illegal
    );

  pc_q <= pc_q_s;

  -- AXI fetch master (entity_name)
  U_FETCH: entity work.entity_name
    generic map (
      C_M_AXI_ID_WIDTH     => 1,
      C_M_AXI_ADDR_WIDTH   => 32,
      C_M_AXI_DATA_WIDTH   => 32,
      C_M_AXI_AWUSER_WIDTH => 1,
      C_M_AXI_ARUSER_WIDTH => 1,
      C_M_AXI_WUSER_WIDTH  => 1,
      C_M_AXI_RUSER_WIDTH  => 1,
      C_M_AXI_BUSER_WIDTH  => 1
    )
    port map (
      Start_read    => eyu_start_read,
      Read_address  => pc_q_s,
      Read_Done     => fetch_done,
      Read_Data     => fetch_data,
      Error         => fetch_error,
      M_AXI_ACLK    => clk,
      M_AXI_ARESETN => rstn_axi,
      -- AR
      M_AXI_ARID    => M_AXI_ARID,
      M_AXI_ARADDR  => M_AXI_ARADDR,
      M_AXI_ARLEN   => M_AXI_ARLEN,
      M_AXI_ARSIZE  => M_AXI_ARSIZE,
      M_AXI_ARBURST => M_AXI_ARBURST,
      M_AXI_ARLOCK  => M_AXI_ARLOCK,
      M_AXI_ARCACHE => M_AXI_ARCACHE,
      M_AXI_ARPROT  => M_AXI_ARPROT,
      M_AXI_ARQOS   => M_AXI_ARQOS,
      M_AXI_ARUSER  => M_AXI_ARUSER,
      M_AXI_ARVALID => M_AXI_ARVALID,
      M_AXI_ARREADY => M_AXI_ARREADY,
      -- R
      M_AXI_RID     => M_AXI_RID,
      M_AXI_RDATA   => M_AXI_RDATA,
      M_AXI_RRESP   => M_AXI_RRESP,
      M_AXI_RLAST   => M_AXI_RLAST,
      M_AXI_RUSER   => M_AXI_RUSER,
      M_AXI_RVALID  => M_AXI_RVALID,
      M_AXI_RREADY  => M_AXI_RREADY,
      -- AW/W/B passthrough
      M_AXI_AWID    => M_AXI_AWID,
      M_AXI_AWADDR  => M_AXI_AWADDR,
      M_AXI_AWLEN   => M_AXI_AWLEN,
      M_AXI_AWSIZE  => M_AXI_AWSIZE,
      M_AXI_AWBURST => M_AXI_AWBURST,
      M_AXI_AWLOCK  => M_AXI_AWLOCK,
      M_AXI_AWCACHE => M_AXI_AWCACHE,
      M_AXI_AWPROT  => M_AXI_AWPROT,
      M_AXI_AWQOS   => M_AXI_AWQOS,
      M_AXI_AWUSER  => M_AXI_AWUSER,
      M_AXI_AWVALID => M_AXI_AWVALID,
      M_AXI_AWREADY => M_AXI_AWREADY,
      M_AXI_WDATA   => M_AXI_WDATA,
      M_AXI_WSTRB   => M_AXI_WSTRB,
      M_AXI_WLAST   => M_AXI_WLAST,
      M_AXI_WUSER   => M_AXI_WUSER,
      M_AXI_WVALID  => M_AXI_WVALID,
      M_AXI_WREADY  => M_AXI_WREADY,
      M_AXI_BID     => M_AXI_BID,
      M_AXI_BRESP   => M_AXI_BRESP,
      M_AXI_BUSER   => M_AXI_BUSER,
      M_AXI_BVALID  => M_AXI_BVALID,
      M_AXI_BREADY  => M_AXI_BREADY
    );
    
  M_AXI_ARESETN <= eyu_axi_resetn;

  -- simple fetch/await loop
  process(clk)
  begin
    if rising_edge(clk) then
      if reset='1' then
        st <= S_FETCH; eyu_start_read <= '0'; instr_r <= (others=>'0');
      else
        case st is
          when S_FETCH =>
            eyu_start_read <= '1';
            st <= S_WAIT;
          when S_WAIT  =>
            eyu_start_read <= '0';
            if (fetch_done='1') or (fetch_error='1') then
              instr_r <= instr_c;     -- deliver instruction to decoder
              st      <= S_FETCH;     -- next fetch
            end if;
        end case;
      end if;
    end if;
  end process;

end Behavioral;
