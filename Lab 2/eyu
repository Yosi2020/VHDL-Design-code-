R_FSM_Process: process(M_AXI_ACLK) is
begin
  if rising_edge(M_AXI_ACLK) then
    if (M_AXI_ARESETN = '0') then
      eyu_r_state   <= R_IDLE;
      M_AXI_RREADY  <= '0';
      eyu_read_done <= '0';
      Error         <= '0';
      for i in 0 to C_M_AXI_DATA_WIDTH-1 loop
        Read_Data(i) <= '0';
      end loop;
    else
      case eyu_r_state is
        when R_IDLE =>
          M_AXI_RREADY  <= '0';
          eyu_read_done <= '0';
          Error         <= '0';
          if (eyu_inflight = '1') then
            M_AXI_RREADY <= '1';
            eyu_r_state  <= R_WAIT_DATA;
          end if;

        when R_WAIT_DATA =>
          if (M_AXI_RVALID = '1') then
            -- bit-accurate copy 31:0 -> 0..31 (no reversal)
            for i in 0 to C_M_AXI_DATA_WIDTH-1 loop
              Read_Data(i) <= M_AXI_RDATA(i);
            end loop;
            Error <= (M_AXI_RRESP /= "00");
            if (M_AXI_RLAST = '1') then
              M_AXI_RREADY <= '0';
              eyu_r_state  <= R_DONE;      -- do NOT raise Read_Done here
            end if;
          end if;

        when R_DONE =>
          eyu_read_done <= '1';            -- 1-cycle pulse
          eyu_r_state   <= R_IDLE;
      end case;
    end if;
  end if;
end process;
