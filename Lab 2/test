library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.NUMERIC_STD.ALL;

entity tb_entity_name is end tb_entity_name;

architecture sim of tb_entity_name is
  constant C_ID_W   : integer := 1;
  constant C_ADDR_W : integer := 32;
  constant C_DATA_W : integer := 32;

  -- clock/reset
  signal clk  : std_logic := '0';
  signal rstn : std_logic := '0';

  -- DUT control/status
  signal Start_read   : std_logic := '0';
  signal Read_address : std_logic_vector(C_ADDR_W-1 downto 0) := (others=>'0');
  signal Read_Done    : std_logic;
  signal Read_Data    : std_logic_vector(0 to C_DATA_W-1);
  signal Error        : std_logic;

  -- AXI Read Address/Data
  signal M_AXI_ARID    : std_logic_vector(C_ID_W-1 downto 0);
  signal M_AXI_ARADDR  : std_logic_vector(C_ADDR_W-1 downto 0);
  signal M_AXI_ARLEN   : std_logic_vector(7 downto 0);
  signal M_AXI_ARSIZE  : std_logic_vector(2 downto 0);
  signal M_AXI_ARBURST : std_logic_vector(1 downto 0);
  signal M_AXI_ARLOCK  : std_logic;
  signal M_AXI_ARCACHE : std_logic_vector(3 downto 0);
  signal M_AXI_ARPROT  : std_logic_vector(2 downto 0);
  signal M_AXI_ARQOS   : std_logic_vector(3 downto 0);
  signal M_AXI_ARUSER  : std_logic_vector(0 downto 0);
  signal M_AXI_ARVALID : std_logic;
  signal M_AXI_ARREADY : std_logic := '1';  -- always ready

  signal M_AXI_RID     : std_logic_vector(C_ID_W-1 downto 0) := (others=>'0');
  signal M_AXI_RDATA   : std_logic_vector(C_DATA_W-1 downto 0) := (others=>'0');
  signal M_AXI_RRESP   : std_logic_vector(1 downto 0) := "00";
  signal M_AXI_RLAST   : std_logic := '0';
  signal M_AXI_RUSER   : std_logic_vector(0 downto 0) := (others=>'0');
  signal M_AXI_RVALID  : std_logic := '0';
  signal M_AXI_RREADY  : std_logic;

  -- AXI write (unused; declared to match DUT)
  signal M_AXI_AWID    : std_logic_vector(C_ID_W-1 downto 0);
  signal M_AXI_AWADDR  : std_logic_vector(C_ADDR_W-1 downto 0);
  signal M_AXI_AWLEN   : std_logic_vector(7 downto 0);
  signal M_AXI_AWSIZE  : std_logic_vector(2 downto 0);
  signal M_AXI_AWBURST : std_logic_vector(1 downto 0);
  signal M_AXI_AWLOCK  : std_logic;
  signal M_AXI_AWCACHE : std_logic_vector(3 downto 0);
  signal M_AXI_AWPROT  : std_logic_vector(2 downto 0);
  signal M_AXI_AWQOS   : std_logic_vector(3 downto 0);
  signal M_AXI_AWUSER  : std_logic_vector(0 downto 0);
  signal M_AXI_AWVALID : std_logic;
  signal M_AXI_AWREADY : std_logic := '0';
  signal M_AXI_WDATA   : std_logic_vector(C_DATA_W-1 downto 0);
  signal M_AXI_WSTRB   : std_logic_vector(C_DATA_W/8-1 downto 0);
  signal M_AXI_WLAST   : std_logic;
  signal M_AXI_WUSER   : std_logic_vector(0 downto 0);
  signal M_AXI_WVALID  : std_logic;
  signal M_AXI_WREADY  : std_logic := '0';
  signal M_AXI_BID     : std_logic_vector(C_ID_W-1 downto 0) := (others=>'0');
  signal M_AXI_BRESP   : std_logic_vector(1 downto 0) := "00";
  signal M_AXI_BUSER   : std_logic_vector(0 downto 0) := (others=>'0');
  signal M_AXI_BVALID  : std_logic := '0';
  signal M_AXI_BREADY  : std_logic;

  -- ROM for responses (word address = ARADDR(31:2))
  type rom_t is array (0 to 255) of std_logic_vector(31 downto 0);
  constant ROM : rom_t := (
    0 => x"00000013",  -- NOP
    1 => x"00500093",  -- ADDI x1,x0,5
    2 => x"00C00113",  -- ADDI x2,x0,12
    3 => x"002081B3",  -- ADD  x3,x1,x2
    others => x"00000013"
  );
  signal aword   : integer range 0 to 255 := 0;
  signal pending : std_logic := '0';
  signal delay   : integer range 0 to 3 := 0;

  -- helper: convert 31:0 → 0:31 (DUT Read_Data is 0..31)
  function to_up(v : std_logic_vector(31 downto 0)) return std_logic_vector is
    variable r : std_logic_vector(0 to 31);
  begin for i in 0 to 31 loop r(i) := v(i); end loop; return r; end;

  function w32(x : natural) return std_logic_vector is
  begin return std_logic_vector(to_unsigned(x, 32)); end;

begin
  -- 100 MHz clock & reset
  clk  <= not clk after 5 ns;
  process begin rstn <= '0'; wait for 80 ns; rstn <= '1'; wait; end process;

  -- DUT
  U_DUT: entity work.entity_name
    generic map (
      C_M_AXI_ID_WIDTH     => C_ID_W,
      C_M_AXI_ADDR_WIDTH   => C_ADDR_W,
      C_M_AXI_DATA_WIDTH   => C_DATA_W,
      C_M_AXI_AWUSER_WIDTH => 1,
      C_M_AXI_ARUSER_WIDTH => 1,
      C_M_AXI_WUSER_WIDTH  => 1,
      C_M_AXI_RUSER_WIDTH  => 1,
      C_M_AXI_BUSER_WIDTH  => 1
    )
    port map (
      Start_read    => Start_read,
      Read_address  => Read_address,
      Read_Done     => Read_Done,
      Read_Data     => Read_Data,
      Error         => Error,
      M_AXI_ACLK    => clk,
      M_AXI_ARESETN => rstn,
      -- AR
      M_AXI_ARID    => M_AXI_ARID,
      M_AXI_ARADDR  => M_AXI_ARADDR,
      M_AXI_ARLEN   => M_AXI_ARLEN,
      M_AXI_ARSIZE  => M_AXI_ARSIZE,
      M_AXI_ARBURST => M_AXI_ARBURST,
      M_AXI_ARLOCK  => M_AXI_ARLOCK,
      M_AXI_ARCACHE => M_AXI_ARCACHE,
      M_AXI_ARPROT  => M_AXI_ARPROT,
      M_AXI_ARQOS   => M_AXI_ARQOS,
      M_AXI_ARUSER  => M_AXI_ARUSER,
      M_AXI_ARVALID => M_AXI_ARVALID,
      M_AXI_ARREADY => M_AXI_ARREADY,
      -- R
      M_AXI_RID     => M_AXI_RID,
      M_AXI_RDATA   => M_AXI_RDATA,
      M_AXI_RRESP   => M_AXI_RRESP,
      M_AXI_RLAST   => M_AXI_RLAST,
      M_AXI_RUSER   => M_AXI_RUSER,
      M_AXI_RVALID  => M_AXI_RVALID,
      M_AXI_RREADY  => M_AXI_RREADY,
      -- AW/W/B (unused)
      M_AXI_AWID    => M_AXI_AWID,
      M_AXI_AWADDR  => M_AXI_AWADDR,
      M_AXI_AWLEN   => M_AXI_AWLEN,
      M_AXI_AWSIZE  => M_AXI_AWSIZE,
      M_AXI_AWBURST => M_AXI_AWBURST,
      M_AXI_AWLOCK  => M_AXI_AWLOCK,
      M_AXI_AWCACHE => M_AXI_AWCACHE,
      M_AXI_AWPROT  => M_AXI_AWPROT,
      M_AXI_AWQOS   => M_AXI_AWQOS,
      M_AXI_AWUSER  => M_AXI_AWUSER,
      M_AXI_AWVALID => M_AXI_AWVALID,
      M_AXI_AWREADY => M_AXI_AWREADY,
      M_AXI_WDATA   => M_AXI_WDATA,
      M_AXI_WSTRB   => M_AXI_WSTRB,
      M_AXI_WLAST   => M_AXI_WLAST,
      M_AXI_WUSER   => M_AXI_WUSER,
      M_AXI_WVALID  => M_AXI_WVALID,
      M_AXI_WREADY  => M_AXI_WREADY,
      M_AXI_BID     => M_AXI_BID,
      M_AXI_BRESP   => M_AXI_BRESP,
      M_AXI_BUSER   => M_AXI_BUSER,
      M_AXI_BVALID  => M_AXI_BVALID,
      M_AXI_BREADY  => M_AXI_BREADY
    );

  -- AXI memory model (single-beat, 2-cycle latency)
  process(clk)
  begin
    if rising_edge(clk) then
      if rstn='0' then
        pending      <= '0';
        M_AXI_RVALID <= '0';
        M_AXI_RLAST  <= '0';
      else
        if (M_AXI_ARVALID='1' and M_AXI_ARREADY='1') then
          aword   <= to_integer(unsigned(M_AXI_ARADDR(31 downto 2)));
          pending <= '1';
          delay   <= 2;
        end if;

        if (M_AXI_RVALID='1' and M_AXI_RREADY='1') then
          M_AXI_RVALID <= '0';
          M_AXI_RLAST  <= '0';
        end if;

        if pending='1' then
          if delay>0 then
            delay <= delay - 1;
          else
            M_AXI_RDATA  <= ROM(aword);
            M_AXI_RRESP  <= "00";
            M_AXI_RVALID <= '1';
            M_AXI_RLAST  <= '1';
            if M_AXI_RREADY='1' then
              pending <= '0';
            end if;
          end if;
        end if;
      end if;
    end if;
  end process;

  -- Stimulus (no procedures → no parser issues)
  process
    variable exp : std_logic_vector(0 to 31);
  begin
    -- reset
    rstn <= '0'; wait for 80 ns; rstn <= '1'; wait for 20 ns;

    -- 1st read
    Read_address <= w32(16#00000000#);
    Start_read   <= '1';  wait until rising_edge(clk);  Start_read <= '0';
    wait until Read_Done='1';
    exp := to_up(ROM(to_integer(unsigned(Read_address(31 downto 2)))));
    assert Read_Data = exp report "Mismatch @0x0" severity failure;
    wait until rising_edge(clk); assert Read_Done='0' severity failure;

    -- 2nd read
    Read_address <= w32(16#00000004#);
    Start_read   <= '1';  wait until rising_edge(clk);  Start_read <= '0';
    wait until Read_Done='1';
    exp := to_up(ROM(to_integer(unsigned(Read_address(31 downto 2)))));
    assert Read_Data = exp report "Mismatch @0x4" severity failure;
    wait until rising_edge(clk); assert Read_Done='0' severity failure;

    -- 3rd read
    Read_address <= w32(16#00000008#);
    Start_read   <= '1';  wait until rising_edge(clk);  Start_read <= '0';
    wait until Read_Done='1';
    exp := to_up(ROM(to_integer(unsigned(Read_address(31 downto 2)))));
    assert Read_Data = exp report "Mismatch @0x8" severity failure;
    wait until rising_edge(clk); assert Read_Done='0' severity failure;

    report "TB PASS: entity_name fetch path OK" severity note;
    wait;
  end process;

end architecture;
