library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.NUMERIC_STD.ALL;

entity AXI_Bus_Manager_Example is
  generic (
    C_M_AXI_ID_WIDTH    : integer := 1;
    C_M_AXI_ADDR_WIDTH  : integer := 32;
    C_M_AXI_DATA_WIDTH  : integer := 32;
    C_M_AXI_ARUSER_WIDTH: integer := 0;
    C_M_AXI_RUSER_WIDTH : integer := 0;
    C_M_AXI_AWUSER_WIDTH: integer := 0;
    C_M_AXI_WUSER_WIDTH : integer := 0;
    C_M_AXI_BUSER_WIDTH : integer := 0;
    C_M_AXI_BURST_LEN   : integer := 1  -- number of beats per burst (1 for single-beat)
  );
  port (
    -- Control signals for fetch unit
    Start_read    : in  std_logic;                                             -- Trigger to start a read transaction
    Read_address  : in  std_logic_vector(C_M_AXI_ADDR_WIDTH-1 downto 0);       -- Address to fetch from (e.g., current PC)
    Read_Done     : out std_logic;                                            -- Flag: Read transaction completed
    Read_Data     : out std_logic_vector(C_M_AXI_DATA_WIDTH-1 downto 0);       -- Data word fetched from memory
    Error         : out std_logic;                                            -- Flag: Error occurred during fetch (AXI RRESP not OKAY)
    -- AXI4 Master Interface signals (Instruction memory bus)
    M_AXI_ACLK    : in  std_logic;
    M_AXI_ARESETN : in  std_logic;
    -- Read address channel (AR)
    M_AXI_ARID    : out std_logic_vector(C_M_AXI_ID_WIDTH-1 downto 0);
    M_AXI_ARADDR  : out std_logic_vector(C_M_AXI_ADDR_WIDTH-1 downto 0);
    M_AXI_ARLEN   : out std_logic_vector(7 downto 0);
    M_AXI_ARSIZE  : out std_logic_vector(2 downto 0);
    M_AXI_ARBURST : out std_logic_vector(1 downto 0);
    M_AXI_ARLOCK  : out std_logic;
    M_AXI_ARCACHE : out std_logic_vector(3 downto 0);
    M_AXI_ARPROT  : out std_logic_vector(2 downto 0);
    M_AXI_ARQOS   : out std_logic_vector(3 downto 0);
    M_AXI_ARUSER  : out std_logic_vector(0 downto 0);  -- User signal (not used, 1-bit tie-off)
    M_AXI_ARVALID : out std_logic;
    M_AXI_ARREADY : in  std_logic;
    -- Read data channel (R)
    M_AXI_RID     : in  std_logic_vector(C_M_AXI_ID_WIDTH-1 downto 0);
    M_AXI_RDATA   : in  std_logic_vector(C_M_AXI_DATA_WIDTH-1 downto 0);
    M_AXI_RRESP   : in  std_logic_vector(1 downto 0);
    M_AXI_RLAST   : in  std_logic;
    M_AXI_RUSER   : in  std_logic_vector(0 downto 0);  -- User signal (not used, 1-bit)
    M_AXI_RVALID  : in  std_logic;
    M_AXI_RREADY  : out std_logic;
    -- Write address channel (AW) - not used in Lab 3 (tie-offs)
    M_AXI_AWID    : out std_logic_vector(C_M_AXI_ID_WIDTH-1 downto 0);
    M_AXI_AWADDR  : out std_logic_vector(C_M_AXI_ADDR_WIDTH-1 downto 0);
    M_AXI_AWLEN   : out std_logic_vector(7 downto 0);
    M_AXI_AWSIZE  : out std_logic_vector(2 downto 0);
    M_AXI_AWBURST : out std_logic_vector(1 downto 0);
    M_AXI_AWLOCK  : out std_logic;
    M_AXI_AWCACHE : out std_logic_vector(3 downto 0);
    M_AXI_AWPROT  : out std_logic_vector(2 downto 0);
    M_AXI_AWQOS   : out std_logic_vector(3 downto 0);
    M_AXI_AWUSER  : out std_logic_vector(0 downto 0);  -- User signal (not used)
    M_AXI_AWVALID : out std_logic;
    M_AXI_AWREADY : in  std_logic;
    -- Write data channel (W) - not used
    M_AXI_WDATA   : out std_logic_vector(C_M_AXI_DATA_WIDTH-1 downto 0);
    M_AXI_WSTRB   : out std_logic_vector((C_M_AXI_DATA_WIDTH/8)-1 downto 0);
    M_AXI_WLAST   : out std_logic;
    M_AXI_WUSER   : out std_logic_vector(0 downto 0);  -- User signal (not used)
    M_AXI_WVALID  : out std_logic;
    M_AXI_WREADY  : in  std_logic;
    -- Write response channel (B) - not used
    M_AXI_BID     : in  std_logic_vector(C_M_AXI_ID_WIDTH-1 downto 0);
    M_AXI_BRESP   : in  std_logic_vector(1 downto 0);
    M_AXI_BUSER   : in  std_logic_vector(0 downto 0);  -- User signal (not used)
    M_AXI_BVALID  : in  std_logic;
    M_AXI_BREADY  : out std_logic
  );
end AXI_Bus_Manager_Example;

architecture Behavioral of AXI_Bus_Manager_Example is

  -- Define state types for the read address and read data channel FSMs
  type AR_State_Type is (AR_IDLE, AR_SEND_ADDR);
  type R_State_Type  is (R_IDLE, R_WAIT_DATA, R_DONE);
  signal eyu_ar_state  : AR_State_Type := AR_IDLE;
  signal eyu_r_state   : R_State_Type  := R_IDLE;

begin
  --------------------------------------------------------------------
  -- Default assignments for constant AXI control signals (tie-offs)
  --------------------------------------------------------------------
  -- Read Address channel static signals
  M_AXI_ARID    <= (others => '0');       -- Single ID thread = 0:contentReference[oaicite:13]{index=13}
  M_AXI_ARLEN   <= (others => '0');       -- Burst length = 0 (single beat):contentReference[oaicite:14]{index=14}
  M_AXI_ARSIZE  <= "010";                 -- 4 bytes per beat (32-bit word)
  M_AXI_ARBURST <= "01";                  -- INCR burst type (incrementing address)
  M_AXI_ARLOCK  <= '0';                   -- No lock
  M_AXI_ARCACHE <= "0011";                -- Normal, non-cacheable, bufferable :contentReference[oaicite:15]{index=15}
  M_AXI_ARPROT  <= "000";                 -- Unprivileged, secure, data access :contentReference[oaicite:16]{index=16}
  M_AXI_ARQOS   <= (others => '0');       -- Not using QoS, tie to 0
  M_AXI_ARUSER  <= (others => '0');       -- Not used user signal

  -- Write channels (AW, W, B) static signals (not used in fetch, tie-offs)
  M_AXI_AWID    <= (others => '0');
  M_AXI_AWADDR  <= (others => '0');
  M_AXI_AWLEN   <= (others => '0');
  M_AXI_AWSIZE  <= "010";        -- (assuming 32-bit writes if used, tie to 4 bytes)
  M_AXI_AWBURST <= "01";
  M_AXI_AWLOCK  <= '0';
  M_AXI_AWCACHE <= "0011";
  M_AXI_AWPROT  <= "000";
  M_AXI_AWQOS   <= (others => '0');
  M_AXI_AWUSER  <= (others => '0');
  M_AXI_AWVALID <= '0';          -- never initiate writes in this unit
  M_AXI_WDATA   <= (others => '0');
  M_AXI_WSTRB   <= (others => '0');
  M_AXI_WLAST   <= '0';
  M_AXI_WUSER   <= (others => '0');
  M_AXI_WVALID  <= '0';
  M_AXI_BREADY  <= '0';          -- not expecting any write responses

  --------------------------------------------------------------------
  -- Read Address Channel FSM: handles AR handshaking 
  --------------------------------------------------------------------
  AR_FSM_Process: process(M_AXI_ACLK) is
  begin
    if rising_edge(M_AXI_ACLK) then
      if (M_AXI_ARESETN = '0') then   -- Active-low reset check
        -- Reset state: clear AR signal outputs
        eyu_ar_state   <= AR_IDLE;
        M_AXI_ARVALID <= '0';
        M_AXI_ARADDR  <= (others => '0');
      else
        case eyu_ar_state is
          when AR_IDLE =>
            -- Wait for a start of read request
            if (Start_read = '1') then
              -- Latch address and start the read transaction
              M_AXI_ARADDR  <= Read_address;
              M_AXI_ARVALID <= '1';   -- assert ARVALID to initiate handshake
              eyu_ar_state  <= AR_SEND_ADDR;
            end if;

          when AR_SEND_ADDR =>
            -- Address phase in progress: wait for slave to accept the address
            if (M_AXI_ARVALID = '1' and M_AXI_ARREADY = '1') then
              -- Handshake complete: address accepted
              M_AXI_ARVALID <= '0';   -- deassert ARVALID (one-shot request)
              -- Note: ARADDR and control signals remain stable throughout handshake
              eyu_ar_state  <= AR_IDLE;
            end if;

          when others =>
            eyu_ar_state <= AR_IDLE;
        end case;
      end if;
    end if;
  end process AR_FSM_Process;

  --------------------------------------------------------------------
  -- Read Data Channel FSM: handles R data reception and completion
  --------------------------------------------------------------------
  R_FSM_Process: process(M_AXI_ACLK) is
  begin
    if rising_edge(M_AXI_ACLK) then
      if (M_AXI_ARESETN = '0') then   -- Synchronous reset for R-channel
        eyu_r_state   <= R_IDLE;
        M_AXI_RREADY <= '0';
        Read_Done    <= '0';
        Error        <= '0';
        Read_Data    <= (others => '0');
      else
        case eyu_r_state is
          when R_IDLE =>
            -- Idle: no pending read. Set RREADY low, clear flags.
            M_AXI_RREADY <= '0';
            Read_Done    <= '0';
            Error        <= '0';
            -- Transition to wait state on Start_read (transaction initiated)
            if (Start_read = '1') then
              M_AXI_RREADY <= '1';    -- be ready to accept read data
              -- Clear output flags for new transaction
              Read_Done    <= '0';
              Error        <= '0';
              eyu_r_state  <= R_WAIT_DATA;
            end if;

          when R_WAIT_DATA =>
            -- Waiting for data from the slave
            if (M_AXI_RVALID = '1') then
              -- A data beat is available on the bus
              Read_Data <= M_AXI_RDATA;   -- capture the returned data word
              -- Check for any error response
              if (M_AXI_RRESP = "00") then
                Error <= '0';            -- OKAY response (no error)
              else
                Error <= '1';            -- SLVERR/DECERR, flag an error
              end if;
              -- For single-beat transfer, RLAST should be 1 with this data
              if (M_AXI_RLAST = '1') then
                -- Last (and only) beat of the burst received
                Read_Done    <= '1';     -- signal completion of read
                M_AXI_RREADY <= '0';     -- not ready for more (end of burst)
                eyu_r_state  <= R_DONE;  -- go to done state to finalize
              end if;
              -- (If multi-beat bursts were used, we would remain in R_WAIT_DATA 
              -- until RLAST is encountered, collecting data as needed)
            end if;

          when R_DONE =>
            -- One cycle done state: hold Read_Done (and Error) high, then clear
            Read_Done   <= '1';   -- (remains asserted for this extra cycle)
            -- Error stays asserted if it was set (no need to reassign here)
            -- Transition back to idle on next cycle, clear flags
            eyu_r_state <= R_IDLE;
            Read_Done   <= '0';
            Error       <= '0';
            -- Note: Read_Data can retain the last fetched value until next use
          
          when others =>
            eyu_r_state <= R_IDLE;
        end case;
      end if;
    end if;
  end process R_FSM_Process;

end Behavioral;
