library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.NUMERIC_STD.ALL;

entity tb_fetch_connector is end tb_fetch_connector;

architecture sim of tb_fetch_connector is
  signal clk   : std_logic := '0';
  signal reset : std_logic := '1';

  -- AXI wires between TB mem model and DUT wrapper
  signal M_AXI_ARID    : std_logic_vector(0 downto 0);
  signal M_AXI_ARADDR  : std_logic_vector(31 downto 0);
  signal M_AXI_ARLEN   : std_logic_vector(7 downto 0);
  signal M_AXI_ARSIZE  : std_logic_vector(2 downto 0);
  signal M_AXI_ARBURST : std_logic_vector(1 downto 0);
  signal M_AXI_ARLOCK  : std_logic;
  signal M_AXI_ARCACHE : std_logic_vector(3 downto 0);
  signal M_AXI_ARPROT  : std_logic_vector(2 downto 0);
  signal M_AXI_ARQOS   : std_logic_vector(3 downto 0);
  signal M_AXI_ARUSER  : std_logic_vector(0 downto 0);
  signal M_AXI_ARVALID : std_logic;
  signal M_AXI_ARREADY : std_logic := '0';

  signal M_AXI_RID     : std_logic_vector(0 downto 0) := (others=>'0');
  signal M_AXI_RDATA   : std_logic_vector(31 downto 0) := (others=>'0');
  signal M_AXI_RRESP   : std_logic_vector(1 downto 0) := "00";
  signal M_AXI_RLAST   : std_logic := '0';
  signal M_AXI_RUSER   : std_logic_vector(0 downto 0) := (others=>'0');
  signal M_AXI_RVALID  : std_logic := '0';
  signal M_AXI_RREADY  : std_logic;

  -- AW/W/B (unused, just plumb)
  signal M_AXI_AWID    : std_logic_vector(0 downto 0);
  signal M_AXI_AWADDR  : std_logic_vector(31 downto 0);
  signal M_AXI_AWLEN   : std_logic_vector(7 downto 0);
  signal M_AXI_AWSIZE  : std_logic_vector(2 downto 0);
  signal M_AXI_AWBURST : std_logic_vector(1 downto 0);
  signal M_AXI_AWLOCK  : std_logic;
  signal M_AXI_AWCACHE : std_logic_vector(3 downto 0);
  signal M_AXI_AWPROT  : std_logic_vector(2 downto 0);
  signal M_AXI_AWQOS   : std_logic_vector(3 downto 0);
  signal M_AXI_AWUSER  : std_logic_vector(0 downto 0);
  signal M_AXI_AWVALID : std_logic;
  signal M_AXI_AWREADY : std_logic := '0';
  signal M_AXI_WDATA   : std_logic_vector(31 downto 0);
  signal M_AXI_WSTRB   : std_logic_vector(3 downto 0);
  signal M_AXI_WLAST   : std_logic;
  signal M_AXI_WUSER   : std_logic_vector(0 downto 0);
  signal M_AXI_WVALID  : std_logic;
  signal M_AXI_WREADY  : std_logic := '0';
  signal M_AXI_BID     : std_logic_vector(0 downto 0) := (others=>'0');
  signal M_AXI_BRESP   : std_logic_vector(1 downto 0) := "00";
  signal M_AXI_BUSER   : std_logic_vector(0 downto 0) := (others=>'0');
  signal M_AXI_BVALID  : std_logic := '0';
  signal M_AXI_BREADY  : std_logic;

  -- Observability from the core
  signal pc_q   : std_logic_vector(31 downto 0);
  signal alu_y  : std_logic_vector(31 downto 0);
  signal regA_q : std_logic_vector(31 downto 0);
  signal regB_q : std_logic_vector(31 downto 0);
  signal ill    : std_logic;

  -- ROM for instruction memory (word index = ARADDR(31:2))
  type rom_t is array (0 to 255) of std_logic_vector(31 downto 0);
  constant ROM : rom_t := (
    0 => x"00000013",  -- NOP
    1 => x"00500093",  -- ADDI x1,x0,5
    2 => x"00C00113",  -- ADDI x2,x0,12
    3 => x"002081B3",  -- ADD x3,x1,x2
    others => x"00000013"
  );

  signal aword   : integer range 0 to 255 := 0;
  signal pending : std_logic := '0';
  signal delay   : integer range 0 to 3 := 0;

begin
  -- clk & rst
  clk <= not clk after 5 ns;
  process begin reset <= '1'; wait for 100 ns; reset <= '0'; wait; end process;

  -- DUT wrapper
  U_WRAP: entity work.fetch_connector
    port map (
      clk   => clk,
      reset => reset,
      M_AXI_ACLK    => open,                -- already equals clk
      M_AXI_ARESETN => open,
      -- AXI
      M_AXI_ARID    => M_AXI_ARID,
      M_AXI_ARADDR  => M_AXI_ARADDR,
      M_AXI_ARLEN   => M_AXI_ARLEN,
      M_AXI_ARSIZE  => M_AXI_ARSIZE,
      M_AXI_ARBURST => M_AXI_ARBURST,
      M_AXI_ARLOCK  => M_AXI_ARLOCK,
      M_AXI_ARCACHE => M_AXI_ARCACHE,
      M_AXI_ARPROT  => M_AXI_ARPROT,
      M_AXI_ARQOS   => M_AXI_ARQOS,
      M_AXI_ARUSER  => M_AXI_ARUSER,
      M_AXI_ARVALID => M_AXI_ARVALID,
      M_AXI_ARREADY => M_AXI_ARREADY,
      M_AXI_RID     => M_AXI_RID,
      M_AXI_RDATA   => M_AXI_RDATA,
      M_AXI_RRESP   => M_AXI_RRESP,
      M_AXI_RLAST   => M_AXI_RLAST,
      M_AXI_RUSER   => M_AXI_RUSER,
      M_AXI_RVALID  => M_AXI_RVALID,
      M_AXI_RREADY  => M_AXI_RREADY,
      -- AW/W/B
      M_AXI_AWID    => M_AXI_AWID,
      M_AXI_AWADDR  => M_AXI_AWADDR,
      M_AXI_AWLEN   => M_AXI_AWLEN,
      M_AXI_AWSIZE  => M_AXI_AWSIZE,
      M_AXI_AWBURST => M_AXI_AWBURST,
      M_AXI_AWLOCK  => M_AXI_AWLOCK,
      M_AXI_AWCACHE => M_AXI_AWCACHE,
      M_AXI_AWPROT  => M_AXI_AWPROT,
      M_AXI_AWQOS   => M_AXI_AWQOS,
      M_AXI_AWUSER  => M_AXI_AWUSER,
      M_AXI_AWVALID => M_AXI_AWVALID,
      M_AXI_AWREADY => M_AXI_AWREADY,
      M_AXI_WDATA   => M_AXI_WDATA,
      M_AXI_WSTRB   => M_AXI_WSTRB,
      M_AXI_WLAST   => M_AXI_WLAST,
      M_AXI_WUSER   => M_AXI_WUSER,
      M_AXI_WVALID  => M_AXI_WVALID,
      M_AXI_WREADY  => M_AXI_WREADY,
      M_AXI_BID     => M_AXI_BID,
      M_AXI_BRESP   => M_AXI_BRESP,
      M_AXI_BUSER   => M_AXI_BUSER,
      M_AXI_BVALID  => M_AXI_BVALID,
      M_AXI_BREADY  => M_AXI_BREADY,
      -- core observability
      pc_q        => pc_q,
      alu_y       => alu_y,
      regA_q      => regA_q,
      regB_q      => regB_q,
      eyu_illegal => ill
    );

  -- AXI memory model: single beat, fixed latency
  M_AXI_ARREADY <= '1';  -- always ready
  process(clk)
  begin
    if rising_edge(clk) then
      if reset='1' then
        pending      <= '0';
        M_AXI_RVALID <= '0';
        M_AXI_RLAST  <= '0';
      else
        if (M_AXI_ARVALID='1' and M_AXI_ARREADY='1') then
          aword   <= to_integer(unsigned(M_AXI_ARADDR(31 downto 2)));
          pending <= '1';
          delay   <= 2;
        end if;

        if (M_AXI_RVALID='1' and M_AXI_RREADY='1') then
          M_AXI_RVALID <= '0';
          M_AXI_RLAST  <= '0';
        end if;

        if pending='1' then
          if delay>0 then
            delay <= delay - 1;
          else
            M_AXI_RDATA  <= ROM(aword);
            M_AXI_RRESP  <= "00";
            M_AXI_RVALID <= '1';
            M_AXI_RLAST  <= '1';
            if M_AXI_RREADY='1' then
              pending <= '0';
            end if;
          end if;
        end if;
      end if;
    end if;
  end process;

end architecture;
