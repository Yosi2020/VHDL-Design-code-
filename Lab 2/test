library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.NUMERIC_STD.ALL;

entity fetch_connector is
  port (
    -- System clock/reset
    clk   : in  std_logic;
    reset : in  std_logic;

    -- AXI4 (pass-through to top level)
    M_AXI_ACLK    : out std_logic;
    M_AXI_ARESETN : out std_logic;

    -- AXI Read Address
    M_AXI_ARID    : out std_logic_vector(0 downto 0);
    M_AXI_ARADDR  : out std_logic_vector(31 downto 0);
    M_AXI_ARLEN   : out std_logic_vector(7 downto 0);
    M_AXI_ARSIZE  : out std_logic_vector(2 downto 0);
    M_AXI_ARBURST : out std_logic_vector(1 downto 0);
    M_AXI_ARLOCK  : out std_logic;
    M_AXI_ARCACHE : out std_logic_vector(3 downto 0);
    M_AXI_ARPROT  : out std_logic_vector(2 downto 0);
    M_AXI_ARQOS   : out std_logic_vector(3 downto 0);
    M_AXI_ARUSER  : out std_logic_vector(0 downto 0);
    M_AXI_ARVALID : out std_logic;
    M_AXI_ARREADY : in  std_logic;

    -- AXI Read Data
    M_AXI_RID     : in  std_logic_vector(0 downto 0);
    M_AXI_RDATA   : in  std_logic_vector(31 downto 0);
    M_AXI_RRESP   : in  std_logic_vector(1 downto 0);
    M_AXI_RLAST   : in  std_logic;
    M_AXI_RUSER   : in  std_logic_vector(0 downto 0);
    M_AXI_RVALID  : in  std_logic;
    M_AXI_RREADY  : out std_logic;

    -- AXI Write channels (not used by instruction fetch, still exposed)
    M_AXI_AWID    : out std_logic_vector(0 downto 0);
    M_AXI_AWADDR  : out std_logic_vector(31 downto 0);
    M_AXI_AWLEN   : out std_logic_vector(7 downto 0);
    M_AXI_AWSIZE  : out std_logic_vector(2 downto 0);
    M_AXI_AWBURST : out std_logic_vector(1 downto 0);
    M_AXI_AWLOCK  : out std_logic;
    M_AXI_AWCACHE : out std_logic_vector(3 downto 0);
    M_AXI_AWPROT  : out std_logic_vector(2 downto 0);
    M_AXI_AWQOS   : out std_logic_vector(3 downto 0);
    M_AXI_AWUSER  : out std_logic_vector(0 downto 0);
    M_AXI_AWVALID : out std_logic;
    M_AXI_AWREADY : in  std_logic;
    M_AXI_WDATA   : out std_logic_vector(31 downto 0);
    M_AXI_WSTRB   : out std_logic_vector(3 downto 0);
    M_AXI_WLAST   : out std_logic;
    M_AXI_WUSER   : out std_logic_vector(0 downto 0);
    M_AXI_WVALID  : out std_logic;
    M_AXI_WREADY  : in  std_logic;
    M_AXI_BID     : in  std_logic_vector(0 downto 0);
    M_AXI_BRESP   : in  std_logic_vector(1 downto 0);
    M_AXI_BUSER   : in  std_logic_vector(0 downto 0);
    M_AXI_BVALID  : in  std_logic;
    M_AXI_BREADY  : out std_logic;

    -- Observability: bubbled up from your existing connector
    pc_q        : out std_logic_vector(31 downto 0);
    alu_y       : out std_logic_vector(31 downto 0);
    regA_q      : out std_logic_vector(31 downto 0);
    regB_q      : out std_logic_vector(31 downto 0);
    eyu_illegal : out std_logic
  );
end fetch_connector;

architecture Behavioral of fetch_connector is
  --------------------------------------------------------------------------
  -- Tiny sequencer
  --------------------------------------------------------------------------
  type eyu_seq_state_t is (EYU_FETCH, EYU_WAIT);
  signal eyu_state : eyu_seq_state_t := EYU_FETCH;

  -- AXI manager control/results
  signal eyu_start_read  : std_logic := '0';
  signal eyu_fetch_done  : std_logic := '0';
  signal eyu_fetch_error : std_logic := '0';
  signal eyu_fetch_data  : std_logic_vector(0 to 31) := (others => '0');

  -- Latched instruction for your (decoder+datapath) connector
  signal eyu_instr_c : std_logic_vector(31 downto 0);  -- combinational mapping
  signal eyu_instr_r : std_logic_vector(31 downto 0) := (others => '0'); -- registered, drives connector.eyu

  -- Local view of pc_q from inner connector (also bubbled to top)
  signal eyu_pc_q_s : std_logic_vector(31 downto 0);

begin
  ----------------------------------------------------------------------------
  -- Tie AXI clock/reset outward
  ----------------------------------------------------------------------------
  M_AXI_ACLK    <= clk;
  M_AXI_ARESETN <= not reset;

  ----------------------------------------------------------------------------
  -- Map 0..31 (from AXI manager) into 31 downto 0 word for the core connector
  ----------------------------------------------------------------------------
  gen_map_instr : for i in 0 to 31 generate
    eyu_instr_c(i) <= eyu_fetch_data(i);
  end generate;

  ----------------------------------------------------------------------------
  -- Instantiate your existing connector (decoder + datapath)
  --   entity connector is
  --     port (clk, reset, eyu, pc_q, alu_y, regA_q, regB_q, eyu_illegal);
  ----------------------------------------------------------------------------
  U_CORE: entity work.connector
    port map (
      clk         => clk,
      reset       => reset,
      eyu         => eyu_instr_r,   -- latched instruction word
      pc_q        => eyu_pc_q_s,
      alu_y       => alu_y,
      regA_q      => regA_q,
      regB_q      => regB_q,
      eyu_illegal => eyu_illegal
    );

  -- Bubble out PC
  pc_q <= eyu_pc_q_s;

  ----------------------------------------------------------------------------
  -- Instantiate the AXI instruction fetch manager (your AXI master)
  --   If your entity name differs, update "entity work.entity_name"
  ----------------------------------------------------------------------------
  U_FETCH: entity work.entity_name
    port map (
      -- control
      Start_read   => eyu_start_read,
      Read_address => eyu_pc_q_s,        -- fetch at current PC
      Read_Done    => eyu_fetch_done,
      Read_Data    => eyu_fetch_data,    -- (0 to 31)
      Error        => eyu_fetch_error,

      -- AXI clock/reset
      M_AXI_ACLK    => clk,
      M_AXI_ARESETN => not reset,

      -- AXI Read Address
      M_AXI_ARID    => M_AXI_ARID,
      M_AXI_ARADDR  => M_AXI_ARADDR,
      M_AXI_ARLEN   => M_AXI_ARLEN,
      M_AXI_ARSIZE  => M_AXI_ARSIZE,
      M_AXI_ARBURST => M_AXI_ARBURST,
      M_AXI_ARLOCK  => M_AXI_ARLOCK,
      M_AXI_ARCACHE => M_AXI_ARCACHE,
      M_AXI_ARPROT  => M_AXI_ARPROT,
      M_AXI_ARQOS   => M_AXI_ARQOS,
      M_AXI_ARUSER  => M_AXI_ARUSER,
      M_AXI_ARVALID => M_AXI_ARVALID,
      M_AXI_ARREADY => M_AXI_ARREADY,

      -- AXI Read Data
      M_AXI_RID     => M_AXI_RID,
      M_AXI_RDATA   => M_AXI_RDATA,
      M_AXI_RRESP   => M_AXI_RRESP,
      M_AXI_RLAST   => M_AXI_RLAST,
      M_AXI_RUSER   => M_AXI_RUSER,
      M_AXI_RVALID  => M_AXI_RVALID,
      M_AXI_RREADY  => M_AXI_RREADY,

      -- AXI Write Channels (exposed/tied by this wrapper)
      M_AXI_AWID    => M_AXI_AWID,
      M_AXI_AWADDR  => M_AXI_AWADDR,
      M_AXI_AWLEN   => M_AXI_AWLEN,
      M_AXI_AWSIZE  => M_AXI_AWSIZE,
      M_AXI_AWBURST => M_AXI_AWBURST,
      M_AXI_AWLOCK  => M_AXI_AWLOCK,
      M_AXI_AWCACHE => M_AXI_AWCACHE,
      M_AXI_AWPROT  => M_AXI_AWPROT,
      M_AXI_AWQOS   => M_AXI_AWQOS,
      M_AXI_AWUSER  => M_AXI_AWUSER,
      M_AXI_AWVALID => M_AXI_AWVALID,
      M_AXI_AWREADY => M_AXI_AWREADY,
      M_AXI_WDATA   => M_AXI_WDATA,
      M_AXI_WSTRB   => M_AXI_WSTRB,
      M_AXI_WLAST   => M_AXI_WLAST,
      M_AXI_WUSER   => M_AXI_WUSER,
      M_AXI_WVALID  => M_AXI_WVALID,
      M_AXI_WREADY  => M_AXI_WREADY,
      M_AXI_BID     => M_AXI_BID,
      M_AXI_BRESP   => M_AXI_BRESP,
      M_AXI_BUSER   => M_AXI_BUSER,
      M_AXI_BVALID  => M_AXI_BVALID,
      M_AXI_BREADY  => M_AXI_BREADY
    );

  ----------------------------------------------------------------------------
  -- Tiny sequencer: FETCH -> WAIT (repeat)
  --  - Pulse Start_read one cycle
  --  - On Read_Done, latch instruction into eyu_instr_r
  --  - Core (decoder+datapath) uses eyu_instr_r on the next clock
  ----------------------------------------------------------------------------
  process(clk)
  begin
    if rising_edge(clk) then
      if reset = '1' then
        eyu_state      <= EYU_FETCH;
        eyu_start_read <= '0';
        eyu_instr_r    <= (others => '0');
      else
        case eyu_state is
          when EYU_FETCH =>
            eyu_start_read <= '1';           -- 1-cycle request
            eyu_state      <= EYU_WAIT;

          when EYU_WAIT  =>
            eyu_start_read <= '0';
            if (eyu_fetch_done = '1') or (eyu_fetch_error = '1') then
              eyu_instr_r <= eyu_instr_c;    -- latch fetched instruction
              eyu_state   <= EYU_FETCH;      -- request next instruction
            end if;

          when others    =>
            eyu_state <= EYU_FETCH;
        end case;
      end if;
    end if;
  end process;

end Behavioral;
