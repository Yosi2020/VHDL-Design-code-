library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.NUMERIC_STD.ALL;

entity fetch_connector is
  port (
    clk   : in  std_logic;
    reset : in  std_logic;

    -- AXI outward (single master shared by FETCH and LSU)
    d_M_AXI_ACLK    : out std_logic;
    d_M_AXI_ARESETN : out std_logic;

    -- AXI Read Address
    d_M_AXI_ARID    : out std_logic_vector(0 downto 0);
    d_M_AXI_ARADDR  : out std_logic_vector(31 downto 0);
    d_M_AXI_ARLEN   : out std_logic_vector(7 downto 0);
    d_M_AXI_ARSIZE  : out std_logic_vector(2 downto 0);
    d_M_AXI_ARBURST : out std_logic_vector(1 downto 0);
    d_M_AXI_ARLOCK  : out std_logic;
    d_M_AXI_ARCACHE : out std_logic_vector(3 downto 0);
    d_M_AXI_ARPROT  : out std_logic_vector(2 downto 0);
    d_M_AXI_ARQOS   : out std_logic_vector(3 downto 0);
    d_M_AXI_ARUSER  : out std_logic_vector(0 downto 0);
    d_M_AXI_ARVALID : out std_logic;
    d_M_AXI_ARREADY : in  std_logic;

    -- AXI Read Data
    d_M_AXI_RID     : in  std_logic_vector(0 downto 0);
    d_M_AXI_RDATA   : in  std_logic_vector(31 downto 0);
    d_M_AXI_RRESP   : in  std_logic_vector(1 downto 0);
    d_M_AXI_RLAST   : in  std_logic;
    d_M_AXI_RUSER   : in  std_logic_vector(0 downto 0);
    d_M_AXI_RVALID  : in  std_logic;
    d_M_AXI_RREADY  : out std_logic;

    -- AXI Write (used by LSU; FETCH keeps these idle)
    d_M_AXI_AWID    : out std_logic_vector(0 downto 0);
    d_M_AXI_AWADDR  : out std_logic_vector(31 downto 0);
    d_M_AXI_AWLEN   : out std_logic_vector(7 downto 0);
    d_M_AXI_AWSIZE  : out std_logic_vector(2 downto 0);
    d_M_AXI_AWBURST : out std_logic_vector(1 downto 0);
    d_M_AXI_AWLOCK  : out std_logic;
    d_M_AXI_AWCACHE : out std_logic_vector(3 downto 0);
    d_M_AXI_AWPROT  : out std_logic_vector(2 downto 0);
    d_M_AXI_AWQOS   : out std_logic_vector(3 downto 0);
    d_M_AXI_AWUSER  : out std_logic_vector(0 downto 0);
    d_M_AXI_AWVALID : out std_logic;
    d_M_AXI_AWREADY : in  std_logic;

    d_M_AXI_WDATA   : out std_logic_vector(31 downto 0);
    d_M_AXI_WSTRB   : out std_logic_vector(3 downto 0);
    d_M_AXI_WLAST   : out std_logic;
    d_M_AXI_WUSER   : out std_logic_vector(0 downto 0);
    d_M_AXI_WVALID  : out std_logic;
    d_M_AXI_WREADY  : in  std_logic;

    d_M_AXI_BID     : in  std_logic_vector(0 downto 0);
    d_M_AXI_BRESP   : in  std_logic_vector(1 downto 0);
    d_M_AXI_BUSER   : in  std_logic_vector(0 downto 0);
    d_M_AXI_BVALID  : in  std_logic;
    d_M_AXI_BREADY  : out std_logic;

    -- core observability (as in your TB)
    pc_q        : out std_logic_vector(31 downto 0);
    alu_y       : out std_logic_vector(31 downto 0);
    regA_q      : out std_logic_vector(31 downto 0);
    regB_q      : out std_logic_vector(31 downto 0);
    eyu_BRcond  : inout std_logic_vector(2 downto 0);
    eyu_illegal : out std_logic
  );
end fetch_connector;

architecture Behavioral of fetch_connector is
  ---------------------------------------------------------------------------
  -- FETCH handshake + instruction capture (your existing signals)
  ---------------------------------------------------------------------------
  signal s_start_read     : std_logic := '0';
  signal s_read_done      : std_logic := '0';
  signal s_read_done_d1   : std_logic := '0';
  signal s_error          : std_logic := '0';
  signal s_data           : std_logic_vector(0 to 31) := (others => '0');

  signal instr_c          : std_logic_vector(31 downto 0) := (others => '0');
  signal instr_r          : std_logic_vector(31 downto 0) := (others => '0');

  signal pc_s             : std_logic_vector(31 downto 0);
  signal rstn_axi         : std_logic;
  signal exec_en          : std_logic := '0';  -- 1-cycle execute pulse
  signal exec_en_g        : std_logic := '0';  -- gated (no expressions in port map)
  signal inflight         : std_logic := '0';

  ---------------------------------------------------------------------------
  -- connector <-> LSU wires (from decoder/datapath)
  ---------------------------------------------------------------------------
  signal eyu_lsaddress    : std_logic_vector(31 downto 0);
  signal eyu_store_data   : std_logic_vector(31 downto 0);
  signal eyu_load_data_s  : std_logic_vector(31 downto 0);
  signal eyu_func3        : std_logic_vector(2 downto 0);
  signal eyu_isLOAD       : std_logic;
  signal eyu_isSTORE      : std_logic;

  -- memory controller
  signal mem_active       : std_logic := '0';  -- LSU owns the bus when '1'
  signal mem_check        : std_logic := '0';  -- check next cycle after exec_en
  signal lsu_start_load_s : std_logic := '0';  -- one-cycle pulses (helpers)
  signal lsu_start_store_s: std_logic := '0';
  signal ls_ready         : std_logic;

  ---------------------------------------------------------------------------
  -- Local AXI for FETCH (so we can mux with LSU on the single top bus)
  ---------------------------------------------------------------------------
  signal i_ARADDR  : std_logic_vector(31 downto 0);
  signal i_ARVALID : std_logic;
  signal i_ARREADY : std_logic;
  signal i_RVALID  : std_logic;
  signal i_RLAST   : std_logic;
  signal i_RREADY  : std_logic;

  -- FETCH sidebands (unused by arbiter; fetch produces constants)
  signal i_ARLEN   : std_logic_vector(7 downto 0);
  signal i_ARSIZE  : std_logic_vector(2 downto 0);
  signal i_ARBURST : std_logic_vector(1 downto 0);
  signal i_ARLOCK  : std_logic;
  signal i_ARCACHE : std_logic_vector(3 downto 0);
  signal i_ARPROT  : std_logic_vector(2 downto 0);
  signal i_ARQOS   : std_logic_vector(3 downto 0);
  signal i_ARUSER  : std_logic_vector(0 downto 0);

  -- FETCH write channel (kept idle, but routed locally to avoid bus fights)
  signal i_AWADDR  : std_logic_vector(31 downto 0);
  signal i_AWVALID : std_logic;
  signal i_AWLEN   : std_logic_vector(7 downto 0);
  signal i_AWSIZE  : std_logic_vector(2 downto 0);
  signal i_AWBURST : std_logic_vector(1 downto 0);
  signal i_AWLOCK  : std_logic;
  signal i_AWCACHE : std_logic_vector(3 downto 0);
  signal i_AWPROT  : std_logic_vector(2 downto 0);
  signal i_AWQOS   : std_logic_vector(3 downto 0);
  signal i_AWUSER  : std_logic_vector(0 downto 0);

  signal i_WDATA   : std_logic_vector(31 downto 0);
  signal i_WSTRB   : std_logic_vector(3 downto 0);
  signal i_WLAST   : std_logic;
  signal i_WVALID  : std_logic;
  signal i_BREADY  : std_logic;

  ---------------------------------------------------------------------------
  -- Local AXI for LSU (d_*) that we mux out to the single top bus
  ---------------------------------------------------------------------------
  signal d_ARADDR  : std_logic_vector(31 downto 0);
  signal d_ARVALID : std_logic;
  signal d_ARREADY : std_logic;
  signal d_RDATA   : std_logic_vector(31 downto 0);
  signal d_RVALID  : std_logic;
  signal d_RLAST   : std_logic;
  signal d_RREADY  : std_logic;

  signal d_AWADDR  : std_logic_vector(31 downto 0);
  signal d_AWVALID : std_logic;
  signal d_AWREADY : std_logic;
  signal d_WDATA   : std_logic_vector(31 downto 0);
  signal d_WSTRB   : std_logic_vector(3 downto 0);
  signal d_WLAST   : std_logic;
  signal d_WVALID  : std_logic;
  signal d_WREADY  : std_logic;
  signal d_BRESP   : std_logic_vector(1 downto 0);
  signal d_BVALID  : std_logic;
  signal d_BREADY  : std_logic;
begin
  ---------------------------------------------------------------------------
  -- outward clock/reset mirrors
  ---------------------------------------------------------------------------
  d_M_AXI_ACLK    <= clk;
  rstn_axi      <= not reset;
  d_M_AXI_ARESETN <= rstn_axi;

  -- map 0..31 → 31 downto 0 for instruction capture
  gen_map: for i in 0 to 31 generate
    instr_c(i) <= s_data(i);
  end generate;

  -- gate exec pulse (no expressions in port map)
  exec_en_g <= exec_en and not mem_active;

  ---------------------------------------------------------------------------
  -- CONNECTOR (decoder + datapath)
  ---------------------------------------------------------------------------
  U_CORE: entity work.connector
    port map (
      clk         => clk,
      reset       => reset,
      eyu         => instr_r,
      exec_en     => exec_en_g,     -- one-cycle execute, frozen during mem op

      pc_q        => pc_s,
      alu_y       => alu_y,
      regA_q      => regA_q,
      regB_q      => regB_q,
      eyu_illegal => eyu_illegal,
      eyu_BRcond  => eyu_BRcond,

      -- LSU datapath/decoder wiring
      eyu_lsaddress => eyu_lsaddress,
      eyu_store_data=> eyu_store_data,
      eyu_load_data => eyu_load_data_s,
      eyu_func3     => eyu_func3,
      eyu_isLOAD    => eyu_isLOAD,
      eyu_isSTORE   => eyu_isSTORE
      -- If you added this port in connector, also map:
      -- , eyu_wb_gate => not mem_active     -- blocks early load write
    );
  pc_q <= pc_s;

  ---------------------------------------------------------------------------
  -- FETCH master (wired to local i_* so we can mux a single bus)
  ---------------------------------------------------------------------------
  U_FETCH: entity work.entity_name
    generic map (
      d_C_M_AXI_ID_WIDTH     => 1,
      d_C_M_AXI_ADDR_WIDTH   => 32,
      d_C_M_AXI_DATA_WIDTH   => 32,
      d_C_M_AXI_AWUSER_WIDTH => 1,
      d_C_M_AXI_ARUSER_WIDTH => 1,
      d_C_M_AXI_WUSER_WIDTH  => 1,
      d_C_M_AXI_RUSER_WIDTH  => 1,
      d_C_M_AXI_BUSER_WIDTH  => 1
    )
    port map (
      Start_read   => s_start_read,
      Read_address => pc_s,
      Read_Done    => s_read_done,
      Read_Data    => s_data,
      Error        => s_error,

      d_M_AXI_ACLK    => clk,
      d_M_AXI_ARESETN => rstn_axi,

      -- AR/R → LOCAL i_* (we arbitrate to top below)
      d_M_AXI_ARID    => d_M_AXI_ARID,      -- ID constant from fetch is fine
      d_M_AXI_ARADDR  => i_ARADDR,
      d_M_AXI_ARLEN   => i_ARLEN,
      d_M_AXI_ARSIZE  => i_ARSIZE,
      d_M_AXI_ARBURST => i_ARBURST,
      d_M_AXI_ARLOCK  => i_ARLOCK,
      d_M_AXI_ARCACHE => i_ARCACHE,
      d_M_AXI_ARPROT  => i_ARPROT,
      d_M_AXI_ARQOS   => i_ARQOS,
      d_M_AXI_ARUSER  => i_ARUSER,
      d_M_AXI_ARVALID => i_ARVALID,
      d_M_AXI_ARREADY => i_ARREADY,

      d_M_AXI_RID     => d_M_AXI_RID,
      d_M_AXI_RDATA   => d_M_AXI_RDATA,
      d_M_AXI_RRESP   => d_M_AXI_RRESP,
      d_M_AXI_RLAST   => i_RLAST,
      d_M_AXI_RUSER   => d_M_AXI_RUSER,
      d_M_AXI_RVALID  => i_RVALID,
      d_M_AXI_RREADY  => i_RREADY,

      -- AW/W/B → LOCAL i_* (fetch keeps them idle)
      d_M_AXI_AWID    => d_M_AXI_AWID,
      d_M_AXI_AWADDR  => i_AWADDR,
      d_M_AXI_AWLEN   => i_AWLEN,
      d_M_AXI_AWSIZE  => i_AWSIZE,
      d_M_AXI_AWBURST => i_AWBURST,
      d_M_AXI_AWLOCK  => i_AWLOCK,
      d_M_AXI_AWCACHE => i_AWCACHE,
      d_M_AXI_AWPROT  => i_AWPROT,
      d_M_AXI_AWQOS   => i_AWQOS,
      d_M_AXI_AWUSER  => i_AWUSER,
      d_M_AXI_AWVALID => i_AWVALID,
      d_M_AXI_AWREADY => '0',

      d_M_AXI_WDATA   => i_WDATA,
      d_M_AXI_WSTRB   => i_WSTRB,
      d_M_AXI_WLAST   => i_WLAST,
      d_M_AXI_WUSER   => d_M_AXI_WUSER,
      d_M_AXI_WVALID  => i_WVALID,
      d_M_AXI_WREADY  => '0',

      d_M_AXI_BID     => d_M_AXI_BID,
      d_M_AXI_BRESP   => d_M_AXI_BRESP,
      d_M_AXI_BUSER   => d_M_AXI_BUSER,
      d_M_AXI_BVALID  => '0',
      d_M_AXI_BREADY  => i_BREADY
    );

  ---------------------------------------------------------------------------
  -- LSU (uses its own local d_*; we mux it to the single top bus)
  -- NOTE: your LSU uses M_AXI_ACLK/M_AXI_ARESETN, not clk/reset.
  ---------------------------------------------------------------------------
  U_LSU : entity work.load_store_unit
    port map (
      l_M_AXI_ACLK    => clk,
      l_M_AXI_ARESETN => rstn_axi,

      -- handshake (helpers; no expressions in port map)
      start_load    => lsu_start_load_s,
      start_store   => lsu_start_store_s,
      ls_ready      => ls_ready,

      -- datapath/decoder
      address       => eyu_lsaddress,
      store_data    => eyu_store_data,
      load_data     => eyu_load_data_s,
      func3         => eyu_func3,

      -- AXI (local d_*; arbitrated below to M_AXI_*)
      l_M_AXI_ARADDR  => d_ARADDR,
      l_M_AXI_ARVALID => d_ARVALID,
      l_M_AXI_ARREADY => d_ARREADY,
      l_M_AXI_RDATA   => d_RDATA,
      l_M_AXI_RVALID  => d_RVALID,
      l_M_AXI_RLAST   => d_RLAST,
      l_M_AXI_RREADY  => d_RREADY,

      l_M_AXI_AWADDR  => d_AWADDR,
      l_M_AXI_AWVALID => d_AWVALID,
      l_M_AXI_AWREADY => d_AWREADY,
      l_M_AXI_WDATA   => d_WDATA,
      l_M_AXI_WSTRB   => d_WSTRB,
      l_M_AXI_WVALID  => d_WVALID,
      l_M_AXI_WLAST   => d_WLAST,
      l_M_AXI_WREADY  => d_WREADY,
      l_M_AXI_BRESP   => d_BRESP,
      l_M_AXI_BVALID  => d_BVALID,
      l_M_AXI_BREADY  => d_BREADY
    );

  ---------------------------------------------------------------------------
  -- BUS ARBITER: LSU owns the bus when mem_active=1; else FETCH does.
  -- (Only AR/R are shared in your TB; AW/W/B also routed so stores can work.)
  ---------------------------------------------------------------------------
  -- READ address/data to fabric
  d_M_AXI_ARADDR  <= d_ARADDR  when mem_active='1' else i_ARADDR;
  d_M_AXI_ARVALID <= d_ARVALID when mem_active='1' else i_ARVALID;
  d_M_AXI_RREADY  <= d_RREADY  when mem_active='1' else i_RREADY;

  -- Sidebands: drive safe constants (single-beat, 32-bit, INCR)
  d_M_AXI_ARID    <= (others => '0');
  d_M_AXI_ARLEN   <= (others => '0');
  d_M_AXI_ARSIZE  <= "010";
  d_M_AXI_ARBURST <= "01";
  d_M_AXI_ARLOCK  <= '0';
  d_M_AXI_ARCACHE <= "0010";
  d_M_AXI_ARPROT  <= "000";
  d_M_AXI_ARQOS   <= (others => '0');
  d_M_AXI_ARUSER  <= (others => '0');

  -- return ARREADY/RVALID/RLAST to the active client
  d_ARREADY <= d_M_AXI_ARREADY when mem_active='1' else '0';
  i_ARREADY <= d_M_AXI_ARREADY when mem_active='0' else '0';

  d_RDATA   <= d_M_AXI_RDATA;
  d_RVALID  <= d_M_AXI_RVALID when mem_active='1' else '0';
  d_RLAST   <= d_M_AXI_RLAST  when mem_active='1' else '0';

  i_RVALID  <= d_M_AXI_RVALID when mem_active='0' else '0';
  i_RLAST   <= d_M_AXI_RLAST  when mem_active='0' else '0';

  -- WRITE path belongs to LSU when active, otherwise keep zeros
  d_M_AXI_AWADDR  <= d_AWADDR  when mem_active='1' else (others => '0');
  d_M_AXI_AWVALID <= d_AWVALID when mem_active='1' else '0';
  d_AWREADY     <= d_M_AXI_AWREADY when mem_active='1' else '0';

  d_M_AXI_WDATA   <= d_WDATA   when mem_active='1' else (others => '0');
  d_M_AXI_WSTRB   <= d_WSTRB   when mem_active='1' else (others => '0');
  d_M_AXI_WLAST   <= d_WLAST   when mem_active='1' else '0';
  d_M_AXI_WVALID  <= d_WVALID  when mem_active='1' else '0';
  d_WREADY      <= d_M_AXI_WREADY when mem_active='1' else '0';

  d_M_AXI_BREADY  <= d_BREADY  when mem_active='1' else '0';
  d_BRESP       <= d_M_AXI_BRESP;
  d_BVALID      <= d_M_AXI_BVALID when mem_active='1' else '0';

  -- FETCH write channel is idle via i_* locals; we never drive top AW/W from it.

  ---------------------------------------------------------------------------
  -- CONTROL: start FETCHs, detect mem-op, start LSU, wait for ls_ready.
  ---------------------------------------------------------------------------
  process(clk)
  begin
    if rising_edge(clk) then
      if reset='1' then
        inflight          <= '0';
        s_start_read      <= '0';
        s_read_done_d1    <= '0';
        exec_en           <= '0';
        instr_r           <= (others => '0');
        mem_active        <= '0';
        mem_check         <= '0';
        lsu_start_load_s  <= '0';
        lsu_start_store_s <= '0';
      else
        -- defaults each cycle
        s_start_read      <= '0';
        exec_en           <= '0';
        lsu_start_load_s  <= '0';
        lsu_start_store_s <= '0';
        s_read_done_d1    <= s_read_done;

        -- 1) issue next instruction fetch only when not doing LSU and no inflight
        if (mem_active='0') and (inflight='0') and (mem_check='0') then
          s_start_read <= '1';
          inflight     <= '1';
        end if;

        -- 2) when an instruction returns, present to connector for 1 cycle
        if (s_read_done='1') and (s_read_done_d1='0') then
          instr_r <= instr_c;
          exec_en <= '1';         -- one-cycle execute pulse
          inflight <= '0';
          mem_check <= '1';       -- check next cycle if it's LOAD/STORE
        end if;

        -- 3) on the cycle after exec_en, decide if it was a mem op
        if mem_check='1' then
          mem_check <= '0';
          if (eyu_isLOAD='1' or eyu_isSTORE='1') then
            mem_active <= '1';           -- give bus to LSU
            if eyu_isLOAD='1' then
              lsu_start_load_s <= '1';   -- 1-cycle kick
            else
              lsu_start_store_s <= '1';
            end if;
          end if;
        end if;

        -- 4) when LSU is done, release bus (fetch resumes automatically)
        if ls_ready='1' then
          mem_active <= '0';
        end if;
      end if;
    end if;
  end process;

end Behavioral;
