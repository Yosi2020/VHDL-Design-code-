library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity eyu_fc_rom_tb is end;
architecture sim of eyu_fc_rom_tb is
  constant TCK : time := 10 ns;
  signal clk   : std_logic := '0';
  signal reset : std_logic := '1';

  -- AXI outward (same ports as fetch_connector)
  signal d_M_AXI_ACLK    : std_logic;
  signal d_M_AXI_ARESETN : std_logic;

  -- READ address/data
  signal d_M_AXI_ARID    : std_logic_vector(0 downto 0);
  signal d_M_AXI_ARADDR  : std_logic_vector(31 downto 0);
  signal d_M_AXI_ARLEN   : std_logic_vector(7 downto 0);
  signal d_M_AXI_ARSIZE  : std_logic_vector(2 downto 0);
  signal d_M_AXI_ARBURST : std_logic_vector(1 downto 0);
  signal d_M_AXI_ARLOCK  : std_logic;
  signal d_M_AXI_ARCACHE : std_logic_vector(3 downto 0);
  signal d_M_AXI_ARPROT  : std_logic_vector(2 downto 0);
  signal d_M_AXI_ARQOS   : std_logic_vector(3 downto 0);
  signal d_M_AXI_ARUSER  : std_logic_vector(0 downto 0);
  signal d_M_AXI_ARVALID : std_logic;
  signal d_M_AXI_ARREADY : std_logic;

  signal d_M_AXI_RID     : std_logic_vector(0 downto 0);
  signal d_M_AXI_RDATA   : std_logic_vector(31 downto 0);
  signal d_M_AXI_RRESP   : std_logic_vector(1 downto 0);
  signal d_M_AXI_RLAST   : std_logic;
  signal d_M_AXI_RUSER   : std_logic_vector(0 downto 0);
  signal d_M_AXI_RVALID  : std_logic;
  signal d_M_AXI_RREADY  : std_logic;

  -- WRITE address/data/resp
  signal d_M_AXI_AWID    : std_logic_vector(0 downto 0);
  signal d_M_AXI_AWADDR  : std_logic_vector(31 downto 0);
  signal d_M_AXI_AWLEN   : std_logic_vector(7 downto 0);
  signal d_M_AXI_AWSIZE  : std_logic_vector(2 downto 0);
  signal d_M_AXI_AWBURST : std_logic_vector(1 downto 0);
  signal d_M_AXI_AWLOCK  : std_logic;
  signal d_M_AXI_AWCACHE : std_logic_vector(3 downto 0);
  signal d_M_AXI_AWPROT  : std_logic_vector(2 downto 0);
  signal d_M_AXI_AWQOS   : std_logic_vector(3 downto 0);
  signal d_M_AXI_AWUSER  : std_logic_vector(0 downto 0);
  signal d_M_AXI_AWVALID : std_logic;
  signal d_M_AXI_AWREADY : std_logic;

  signal d_M_AXI_WDATA   : std_logic_vector(31 downto 0);
  signal d_M_AXI_WSTRB   : std_logic_vector(3 downto 0);
  signal d_M_AXI_WLAST   : std_logic;
  signal d_M_AXI_WUSER   : std_logic_vector(0 downto 0);
  signal d_M_AXI_WVALID  : std_logic;
  signal d_M_AXI_WREADY  : std_logic;

  signal d_M_AXI_BID     : std_logic_vector(0 downto 0);
  signal d_M_AXI_BRESP   : std_logic_vector(1 downto 0);
  signal d_M_AXI_BUSER   : std_logic_vector(0 downto 0);
  signal d_M_AXI_BVALID  : std_logic;
  signal d_M_AXI_BREADY  : std_logic;

  -- observability
  signal pc_q, alu_y, regA_q, regB_q : std_logic_vector(31 downto 0);
  signal eyu_BRcond : std_logic_vector(2 downto 0);
  signal eyu_illegal: std_logic;
begin
  -- clock/reset
  clk <= not clk after TCK/2;
  process begin
    reset <= '1'; wait for 100 ns; reset <= '0'; wait;
  end process;

  -- Device Under Test: your connector (kept exactly as you posted, except no 'open' on write)
  U_TOP: entity work.fetch_connector
    port map (
      clk=>clk, reset=>reset,

      d_M_AXI_ACLK    => d_M_AXI_ACLK,
      d_M_AXI_ARESETN => d_M_AXI_ARESETN,

      -- READ
      d_M_AXI_ARID    => d_M_AXI_ARID,
      d_M_AXI_ARADDR  => d_M_AXI_ARADDR,
      d_M_AXI_ARLEN   => d_M_AXI_ARLEN,
      d_M_AXI_ARSIZE  => d_M_AXI_ARSIZE,
      d_M_AXI_ARBURST => d_M_AXI_ARBURST,
      d_M_AXI_ARLOCK  => d_M_AXI_ARLOCK,
      d_M_AXI_ARCACHE => d_M_AXI_ARCACHE,
      d_M_AXI_ARPROT  => d_M_AXI_ARPROT,
      d_M_AXI_ARQOS   => d_M_AXI_ARQOS,
      d_M_AXI_ARUSER  => d_M_AXI_ARUSER,
      d_M_AXI_ARVALID => d_M_AXI_ARVALID,
      d_M_AXI_ARREADY => d_M_AXI_ARREADY,

      d_M_AXI_RID     => d_M_AXI_RID,
      d_M_AXI_RDATA   => d_M_AXI_RDATA,
      d_M_AXI_RRESP   => d_M_AXI_RRESP,
      d_M_AXI_RLAST   => d_M_AXI_RLAST,
      d_M_AXI_RUSER   => d_M_AXI_RUSER,
      d_M_AXI_RVALID  => d_M_AXI_RVALID,
      d_M_AXI_RREADY  => d_M_AXI_RREADY,

      -- WRITE (fully connected; no 'open')
      d_M_AXI_AWID    => d_M_AXI_AWID,
      d_M_AXI_AWADDR  => d_M_AXI_AWADDR,
      d_M_AXI_AWLEN   => d_M_AXI_AWLEN,
      d_M_AXI_AWSIZE  => d_M_AXI_AWSIZE,
      d_M_AXI_AWBURST => d_M_AXI_AWBURST,
      d_M_AXI_AWLOCK  => d_M_AXI_AWLOCK,
      d_M_AXI_AWCACHE => d_M_AXI_AWCACHE,
      d_M_AXI_AWPROT  => d_M_AXI_AWPROT,
      d_M_AXI_AWQOS   => d_M_AXI_AWQOS,
      d_M_AXI_AWUSER  => d_M_AXI_AWUSER,
      d_M_AXI_AWVALID => d_M_AXI_AWVALID,
      d_M_AXI_AWREADY => d_M_AXI_AWREADY,

      d_M_AXI_WDATA   => d_M_AXI_WDATA,
      d_M_AXI_WSTRB   => d_M_AXI_WSTRB,
      d_M_AXI_WLAST   => d_M_AXI_WLAST,
      d_M_AXI_WUSER   => d_M_AXI_WUSER,
      d_M_AXI_WVALID  => d_M_AXI_WVALID,
      d_M_AXI_WREADY  => d_M_AXI_WREADY,

      d_M_AXI_BID     => d_M_AXI_BID,
      d_M_AXI_BRESP   => d_M_AXI_BRESP,
      d_M_AXI_BUSER   => d_M_AXI_BUSER,
      d_M_AXI_BVALID  => d_M_AXI_BVALID,
      d_M_AXI_BREADY  => d_M_AXI_BREADY,

      pc_q=>pc_q, alu_y=>alu_y, regA_q=>regA_q, regB_q=>regB_q,
      eyu_BRcond=>eyu_BRcond, eyu_illegal=>eyu_illegal
    );

  -- Single AXI memory that supports READ and WRITE (initialised from your dataset)
  U_MEM: entity work.eyu_axi_mem_model
    generic map (EYU_ADDR_WIDTH=>32, EYU_DATA_WIDTH=>32, EYU_MEM_DEPTH_WORDS=>4096)
    port map (
      eyu_aclk     => d_M_AXI_ACLK,
      eyu_aresetn  => d_M_AXI_ARESETN,

      -- WRITE
      eyu_s_awaddr => d_M_AXI_AWADDR,
      eyu_s_awvalid=> d_M_AXI_AWVALID,
      eyu_s_awready=> d_M_AXI_AWREADY,
      eyu_s_wdata  => d_M_AXI_WDATA,
      eyu_s_wstrb  => d_M_AXI_WSTRB,
      eyu_s_wlast  => d_M_AXI_WLAST,
      eyu_s_wvalid => d_M_AXI_WVALID,
      eyu_s_wready => d_M_AXI_WREADY,
      eyu_s_bresp  => d_M_AXI_BRESP,
      eyu_s_bvalid => d_M_AXI_BVALID,
      eyu_s_bready => d_M_AXI_BREADY,

      -- READ
      eyu_s_araddr => d_M_AXI_ARADDR,
      eyu_s_arvalid=> d_M_AXI_ARVALID,
      eyu_s_arready=> d_M_AXI_ARREADY,
      eyu_s_rdata  => d_M_AXI_RDATA,
      eyu_s_rresp  => d_M_AXI_RRESP,
      eyu_s_rlast  => d_M_AXI_RLAST,
      eyu_s_rvalid => d_M_AXI_RVALID,
      eyu_s_rready => d_M_AXI_RREADY
    );

  -- Optional: a simple check on the very first fetch
  process
  begin
    wait until d_M_AXI_ARESETN='1';
    wait until (d_M_AXI_RVALID='1' and d_M_AXI_RREADY='1');
    if d_M_AXI_RDATA /= x"00100293" then  -- this is bswap(93021000)
      assert false report "First FETCH unexpected (check byte-swap/init)" severity warning;
    else
      report "First fetch looks OK (00100293)" severity note;
    end if;
    wait; -- keep sim running so you can observe STORE/LOAD waves
  end process;
end architecture;
