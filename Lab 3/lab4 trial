library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.NUMERIC_STD.ALL;

entity rom_model is
  generic (
    eyu_addr_width     : integer := 32;
    eyu_data_width     : integer := 32;
    eyu_mem_depth_word : integer := 1024
  );
  Port (
    -- clock / reset
    eyu_aclk    : in  std_logic;
    eyu_aresetn : in  std_logic;

    -- READ address
    eyu_s_araddr  : in  std_logic_vector(eyu_addr_width-1 downto 0);
    eyu_s_arvalid : in  std_logic;
    eyu_s_arready : out std_logic;

    -- READ data
    eyu_s_rdata   : out std_logic_vector(eyu_data_width-1 downto 0);
    eyu_s_rresp   : out std_logic_vector(1 downto 0);
    eyu_s_rlast   : out std_logic;
    eyu_s_rvalid  : out std_logic;
    eyu_s_rready  : in  std_logic;

    -- WRITE address  (ADDED)
    eyu_s_awaddr  : in  std_logic_vector(eyu_addr_width-1 downto 0);  -- ADDED
    eyu_s_awvalid : in  std_logic;                                     -- ADDED
    eyu_s_awready : out std_logic;                                     -- ADDED

    -- WRITE data     (ADDED)
    eyu_s_wdata   : in  std_logic_vector(eyu_data_width-1 downto 0);   -- ADDED
    eyu_s_wstrb   : in  std_logic_vector(eyu_data_width/8-1 downto 0); -- ADDED
    eyu_s_wlast   : in  std_logic;                                     -- ADDED
    eyu_s_wvalid  : in  std_logic;                                     -- ADDED
    eyu_s_wready  : out std_logic;                                     -- ADDED

    -- WRITE response (ADDED)
    eyu_s_bresp   : out std_logic_vector(1 downto 0);                  -- ADDED
    eyu_s_bvalid  : out std_logic;                                     -- ADDED
    eyu_s_bready  : in  std_logic                                     -- ADDED
  );
end rom_model;

architecture Behavioral of rom_model is
  subtype eyu_word_t is std_logic_vector(eyu_data_width-1 downto 0);
  type eyu_rom_t is array (0 to eyu_mem_depth_word-1) of eyu_word_t;

  -- CHANGED: this array acts as RAM now (your dataset preserved)
  signal eyu_rom : eyu_rom_t := (
    0 => x"93021000",  1 => x"33835200",  2 => x"B3135300",  3 => x"338E5340",
    4 => x"B30E5040",  5 => x"332FD001",  6 => x"B33FD001",  7 => x"B3AA6200",
    8 => x"333B0000",  9 => x"33C4CE01", 10 => x"B3545440", 11 => x"33595400",
   12 => x"B3E95300", 13 => x"33FA7900", 14 => x"63846200", 15 => x"33000000",
   16 => x"6384F201", 17 => x"33000000", 18 => x"6394F201", 19 => x"33000000",
   20 => x"63946200", 21 => x"33000000", 22 => x"63440000", 23 => x"33000000",
   24 => x"63C45E00", 25 => x"33000000", 26 => x"63D45E00", 27 => x"33000000",
   28 => x"63540000", 29 => x"33000000", 30 => x"63E45E00", 31 => x"33000000",
   32 => x"63E4D201", 33 => x"33000000", 34 => x"63F4D201", 35 => x"33000000",
   36 => x"63F45E00", 37 => x"33000000", 38 => x"33000000",
   others => (others => '0')
  );

  -- READ regs (you already had these)
  signal eyu_arready_r : std_logic := '0';
  signal eyu_rvalid_r  : std_logic := '0';
  signal eyu_rdata_r   : std_logic_vector(eyu_data_width-1 downto 0) := (others=>'0');
  signal eyu_araddr_r  : std_logic_vector(eyu_addr_width-1 downto 0) := (others=>'0');
  signal eyu_have_req  : std_logic := '0';

  -- WRITE regs (ADDED)
  signal eyu_awaddr_r  : std_logic_vector(eyu_addr_width-1 downto 0) := (others=>'0'); -- ADDED
  signal eyu_bpend     : std_logic := '0';                                             -- ADDED

  -- *** THE IMPORTANT FIX: internal mirrors for OUT ports we need to read ***
  signal eyu_awready_r : std_logic := '0';  -- ADDED  (drive port, read here)
  signal eyu_wready_r  : std_logic := '0';  -- ADDED
  signal eyu_bvalid_r  : std_logic := '0';  -- ADDED
begin
  --------------------------
  -- constant sidebands
  --------------------------
  eyu_s_rresp <= "00";
  eyu_s_rlast <= '1';
  eyu_s_bresp <= "00";                 -- ADDED

  --------------------------
  -- OUT ports driven from regs
  --------------------------
  eyu_s_arready <= eyu_arready_r;
  eyu_s_rvalid  <= eyu_rvalid_r;
  eyu_s_rdata   <= eyu_rdata_r;

  eyu_s_awready <= eyu_awready_r;      -- ADDED
  eyu_s_wready  <= eyu_wready_r;       -- ADDED
  eyu_s_bvalid  <= eyu_bvalid_r;       -- ADDED

  --------------------------
  -- READY mirrors (no OUT reads)
  --------------------------
  process(eyu_aclk)
  begin
    if rising_edge(eyu_aclk) then
      if eyu_aresetn='0' then
        eyu_arready_r <= '0';
        eyu_awready_r <= '0';          -- ADDED
        eyu_wready_r  <= '0';          -- ADDED
      else
        -- accept new read address only when not outputting a beat
        if (eyu_have_req='0') and (eyu_rvalid_r='0') then
          eyu_arready_r <= '1';
        else
          eyu_arready_r <= '0';
        end if;
        -- this RAM is always ready for a single-beat write
        eyu_awready_r <= '1';          -- ADDED (AXI-lite style)
        eyu_wready_r  <= '1';          -- ADDED
      end if;
    end if;
  end process;

  --------------------------
  -- Main READ/WRITE (single-beat)
  --------------------------
  process(eyu_aclk)
    variable eyu_idx : integer;
    variable wd      : eyu_word_t;
  begin
    if rising_edge(eyu_aclk) then
      if eyu_aresetn='0' then
        -- READ reset
        eyu_rvalid_r <= '0';
        eyu_rdata_r  <= (others=>'0');
        eyu_have_req <= '0';
        eyu_araddr_r <= (others=>'0');
        -- WRITE reset
        eyu_awaddr_r <= (others=>'0');
        eyu_bpend    <= '0';
        eyu_bvalid_r <= '0';           -- ADDED
      else
        ------------------------------
        -- WRITE ADDRESS latch (ADDED)
        ------------------------------
        if (eyu_s_awvalid='1' and eyu_awready_r='1') then  -- ADDED use _r
          eyu_awaddr_r <= eyu_s_awaddr;
        end if;

        ------------------------------
        -- WRITE DATA with lane mask (ADDED)
        ------------------------------
        if (eyu_s_wvalid='1' and eyu_wready_r='1') then    -- ADDED use _r
          eyu_idx := to_integer(unsigned(eyu_awaddr_r(eyu_addr_width-1 downto 2)));
          if (eyu_idx >= 0) and (eyu_idx < eyu_mem_depth_word) then
            wd := eyu_rom(eyu_idx);
            for b in 0 to (eyu_data_width/8 - 1) loop
              if eyu_s_wstrb(b)='1' then
                wd(8*(b+1)-1 downto 8*b) := eyu_s_wdata(8*(b+1)-1 downto 8*b);
              end if;
            end loop;
            eyu_rom(eyu_idx) <= wd;
          end if;
          eyu_bpend <= '1';
        end if;

        ------------------------------
        -- WRITE RESPONSE (ADDED)
        ------------------------------
        if (eyu_bpend='1') and (eyu_bvalid_r='0') then     -- ADDED use _r
          eyu_bvalid_r <= '1';
          eyu_bpend    <= '0';
        elsif (eyu_bvalid_r='1') and (eyu_s_bready='1') then
          eyu_bvalid_r <= '0';
        end if;

        ------------------------------
        -- READ ADDRESS latch (as before)
        ------------------------------
        if (eyu_s_arvalid='1' and eyu_arready_r='1') then
          eyu_araddr_r <= eyu_s_araddr;
          eyu_have_req <= '1';
        end if;

        ------------------------------
        -- READ DATA (single-beat) (as before)
        ------------------------------
        if (eyu_have_req='1' and eyu_rvalid_r='0') then
          eyu_idx := to_integer(unsigned(eyu_araddr_r(eyu_addr_width-1 downto 2)));
          if (eyu_idx >= 0) and (eyu_idx < eyu_mem_depth_word) then
            eyu_rdata_r <= eyu_rom(eyu_idx);
          else
            eyu_rdata_r <= (others => '0');
          end if;
          eyu_rvalid_r <= '1';
          eyu_have_req <= '0';
        elsif (eyu_rvalid_r='1' and eyu_s_rready='1') then
          eyu_rvalid_r <= '0';
        end if;

      end if;
    end if;
  end process;

end Behavioral;
