library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.NUMERIC_STD.ALL;

entity rom_model is
  generic (
    eyu_addr_width      : integer := 32;
    eyu_data_width      : integer := 32;
    eyu_mem_depth_word  : integer := 1024
  );
  port (
    -- clock/reset (from connector top)
    eyu_aclk     : in  std_logic;
    eyu_aresetn  : in  std_logic;

    -- AXI-lite READ-only slave side
    eyu_s_araddr  : in  std_logic_vector(eyu_addr_width-1 downto 0);
    eyu_s_arvalid : in  std_logic;
    eyu_s_arready : out std_logic;

    eyu_s_rdata   : out std_logic_vector(eyu_data_width-1 downto 0);
    eyu_s_rresp   : out std_logic_vector(1 downto 0);
    eyu_s_rlast   : out std_logic;
    eyu_s_rvalid  : out std_logic;
    eyu_s_rready  : in  std_logic
  );
end rom_model;

architecture Behavioral of rom_model is
  -- 32-bit word memory
  type mem_t is array (0 to eyu_mem_length-1) of std_logic_vector(31 downto 0);
  -- *** FILL with your words; first entry must be valid (not 0) ***
  signal rom : mem_t := (
    0  => x"93021000",  -- example word 0
    1  => x"3385200B",
    2  => x"31353003",
    3  => x"38E5340B",
    4  => x"30E50403",
    5  => x"32FD001B",
    6  => x"33FD001B",
    7  => x"00003AAA",
    others => (others => '0')
  );

  -- ADDED: registered handshake signals (do NOT read outputs directly)
  signal araddr_r   : std_logic_vector(eyu_addr_width-1 downto 0) := (others => '0'); -- ADDED
    -- handshake regs
  signal arready_r  : std_logic := '0';   -- ADDED
  signal rvalid_r   : std_logic := '0';   -- ADDED
  signal rdata_r    : std_logic_vector(31 downto 0) := (others => '0'); -- ADDED

begin
  -- fixed sidebands
  eyu_s_rlast <= '1';
  eyu_s_rresp <= "00";

  -- drive outs from regs
  eyu_s_arready <= arready_r;     -- ADDED
  eyu_s_rvalid  <= rvalid_r;      -- ADDED
  eyu_s_rdata   <= rdata_r;       -- ADDED

  process(eyu_clk)
    variable idx : integer;
  begin
    if rising_edge(eyu_clk) then
      if eyu_aresetn = '0' then
        -- ADDED: synchronous reset
        arready_r <= '0';
        rvalid_r  <= '0';
        rdata_r   <= (others => '0');
      else
        -- ADDED: default
        if rvalid_r = '1' and eyu_s_rready = '1' then
          rvalid_r <= '0';
        end if;

        -- ADDED: accept address only when not outputting a beat
        if (arready_r = '1' and eyu_s_arvalid = '1') then
          arready_r <= '0';
          araddr_r  <= eyu_s_araddr;
          -- prepare data and present next cycle
          idx := to_integer(unsigned(eyu_s_araddr(eyu_addr_width-1 downto 2)));
          if idx < eyu_mem_length then
            rdata_r <= rom(idx);
          else
            rdata_r <= (others => '0');
          end if;
          rvalid_r <= '1';
        elsif rvalid_r = '0' then
          arready_r <= '1';
        end if;
      end if;
    end if;
  end process;
end;
