----------------------------------------------------------------------------------
-- Company: 
-- Engineer: 
-- 
-- Create Date: 10/17/2025 01:08:41 PM
-- Design Name: 
-- Module Name: load_store_unit - Behavioral
-- Project Name: 
-- Target Devices: 
-- Tool Versions: 
-- Description: 
-- 
-- Dependencies: 
-- 
-- Revision:
-- Revision 0.01 - File Created
-- Additional Comments:
-- 
----------------------------------------------------------------------------------


library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.numeric_std.all;

-- Uncomment the following library declaration if using
-- arithmetic functions with Signed or Unsigned values
--use IEEE.NUMERIC_STD.ALL;

-- Uncomment the following library declaration if instantiating
-- any Xilinx leaf cells in this code.
--library UNISIM;
--use UNISIM.VComponents.all;

entity load_store_unit is
  generic (
		-- Users can add generic parameters here

		-- User parameters ends
		C_M_TARGET_SLAVE_BASE_ADDR : std_logic_vector	:= x"00000000"; -- Base address of targeted slave
		C_M_AXI_BURST_LEN	     : integer	:= 1; -- Burst Length. Supports 1, 2, 4, 8, 16, 32, 64, 128, 256 burst lengths
		C_M_AXI_ID_WIDTH	     : integer	:= 1; -- Thread ID Width
		C_M_AXI_ADDR_WIDTH	   : integer	:= 32; -- Width of Address Bus
		C_M_AXI_DATA_WIDTH	   : integer	:= 32; -- Width of Data Bus
		C_M_AXI_AWUSER_WIDTH   : integer	:= 1; -- Width of User Write Address Bus
		C_M_AXI_ARUSER_WIDTH   : integer	:= 1; -- Width of User Read Address Bus
		C_M_AXI_WUSER_WIDTH	   : integer	:= 1; -- Width of User Write Data Bus
		C_M_AXI_RUSER_WIDTH	   : integer	:= 1; -- Width of User Read Data Bus
		C_M_AXI_BUSER_WIDTH	   : integer	:= 1  -- Width of User Response Bus
    );
	port (
		-- Users can add ports here. These are SUGGESTED user ports.
		Start_load	 : in std_logic;  -- Initiate AXI load transaction
		Start_store	 : in std_logic;   -- Initiate AXI load transaction
		address : in std_logic_vector(C_M_AXI_ADDR_WIDTH-1 downto 0); 
		store_data : in std_logic_vector(C_M_AXI_ADDR_WIDTH-1 downto 0);
		func3 : in std_logic_vector(2 downto 0);
		load_data : out std_logic_vector(C_M_AXI_ADDR_WIDTH-1 downto 0);
		ls_ready : out std_logic;  -- load store ready
		--reset : in std_logic;
		
		
		-- User ports ends
    -- Global AXI ports
		M_AXI_ACLK	: in std_logic;    -- Global Clock Signal.
		M_AXI_ARESETN	: in std_logic;  -- Global Reset Singal. This Signal is Active Low
    -- AXI Write Address Channel
		M_AXI_AWID	: out std_logic_vector(C_M_AXI_ID_WIDTH-1 downto 0); -- Master Interface Write Address ID
		M_AXI_AWADDR	: out std_logic_vector(C_M_AXI_ADDR_WIDTH-1 downto 0); -- Master Interface Write Address
		M_AXI_AWLEN	: out std_logic_vector(7 downto 0); -- Burst length. The burst length gives the exact number of transfers in a burst
		M_AXI_AWSIZE	: out std_logic_vector(2 downto 0); -- Burst size. This signal indicates the size of each transfer in the burst
		M_AXI_AWBURST	: out std_logic_vector(1 downto 0); -- Burst type. The burst type and the size information, determine how the address for each transfer within the burst is calculated.
		M_AXI_AWLOCK	: out std_logic; -- Lock type. Provides additional information about the atomic characteristics of the transfer. 
		M_AXI_AWCACHE	: out std_logic_vector(3 downto 0); -- Memory type. This signal indicates how transactions are required to progress through a system.
		M_AXI_AWPROT	: out std_logic_vector(2 downto 0); -- Protection type. This signal indicates the privilege and security level of the transaction, and whether the transaction is a data access or an instruction access.
		M_AXI_AWQOS	: out std_logic_vector(3 downto 0); -- Quality of Service, QoS identifier sent for each write transaction.
		M_AXI_AWUSER	: out std_logic_vector(C_M_AXI_AWUSER_WIDTH-1 downto 0); -- Optional User-defined signal in the write address channel.
		M_AXI_AWVALID	: out std_logic; -- Write address valid. This signal indicates that the channel is signaling valid write address and control information.
		M_AXI_AWREADY	: in std_logic; -- Write address ready. This signal indicates that the slave is ready to accept an address and associated control signals
    -- AXI Write Data Channel
		M_AXI_WDATA	: out std_logic_vector(C_M_AXI_DATA_WIDTH-1 downto 0); -- Master Interface Write Data.
		M_AXI_WSTRB	: out std_logic_vector(C_M_AXI_DATA_WIDTH/8-1 downto 0); -- Write strobes. This signal indicates which byte lanes hold valid data. There is one write strobe bit for each eight bits of the write data bus.
		M_AXI_WLAST	: out std_logic; -- Write last. This signal indicates the last transfer in a write burst.
		M_AXI_WUSER	: out std_logic_vector(C_M_AXI_WUSER_WIDTH-1 downto 0); -- Optional User-defined signal in the write data channel.
		M_AXI_WVALID	: out std_logic; -- Write valid. This signal indicates that valid write data and strobes are available
		M_AXI_WREADY	: in std_logic; -- Write ready. This signal indicates that the slave can accept the write data.
    -- AXI Write Response Channel
		M_AXI_BID	: in std_logic_vector(C_M_AXI_ID_WIDTH-1 downto 0); -- Master Interface Write Response.
		M_AXI_BRESP	: in std_logic_vector(1 downto 0); -- Write response. This signal indicates the status of the write transaction.
		M_AXI_BUSER	: in std_logic_vector(C_M_AXI_BUSER_WIDTH-1 downto 0); -- Optional User-defined signal in the write response channel
		M_AXI_BVALID	: in std_logic; -- Write response valid. This signal indicates that the  channel is signaling a valid write response.
		M_AXI_BREADY	: out std_logic; -- Response ready. This signal indicates that the master can accept a write response.
    -- AXI Read Address Channel
		--M_AXI_ARID	: out std_logic_vector(C_M_AXI_ID_WIDTH-1 downto 0); -- Master Interface Read Address.
		M_AXI_ARADDR	: out std_logic_vector(C_M_AXI_ADDR_WIDTH-1 downto 0); -- Read address. This signal indicates the initial address of a read burst transaction.
		M_AXI_ARLEN	: out std_logic_vector(7 downto 0); -- Burst length. The burst length gives the exact number of transfers in a burst
		M_AXI_ARSIZE	: out std_logic_vector(2 downto 0); -- Burst size. This signal indicates the size of each transfer in the burst
		M_AXI_ARBURST	: out std_logic_vector(1 downto 0); -- Burst type. The burst type and the size information, determine how the address for each transfer within the burst is calculated.
		M_AXI_ARLOCK	: out std_logic; -- Lock type. Provides additional information about the atomic characteristics of the transfer.
		M_AXI_ARCACHE	: out std_logic_vector(3 downto 0); -- Memory type. This signal indicates how transactions are required to progress through a system.
		M_AXI_ARPROT	: out std_logic_vector(2 downto 0); -- Protection type. This signal indicates the privilege and security level of the transaction, and whether the transaction is a data access or an instruction access.
		M_AXI_ARQOS	: out std_logic_vector(3 downto 0); -- Quality of Service, QoS identifier sent for each read transaction
		M_AXI_ARUSER	: out std_logic_vector(C_M_AXI_ARUSER_WIDTH-1 downto 0); -- Optional User-defined signal in the read address channel.
		M_AXI_ARVALID	: out std_logic; -- Write address valid. This signal indicates that the channel is signaling valid read address and control information
		M_AXI_ARREADY	: in std_logic; -- Read address ready. This signal indicates that the slave is ready to accept an address and associated control signals
    -- AXI Read Data Channel
		M_AXI_RID	: in std_logic_vector(C_M_AXI_ID_WIDTH-1 downto 0); -- Read ID tag. This signal is the identification tag for the read data group of signals generated by the slave.
		M_AXI_RDATA	: in std_logic_vector(C_M_AXI_DATA_WIDTH-1 downto 0); -- Master Read Data
		M_AXI_RRESP	: in std_logic_vector(1 downto 0); -- Read response. This signal indicates the status of the read transfer
		M_AXI_RLAST	: in std_logic; -- Read last. This signal indicates the last transfer in a read burst
		M_AXI_RUSER	: in std_logic_vector(C_M_AXI_RUSER_WIDTH-1 downto 0); -- Optional User-defined signal in the read address channel.
		M_AXI_RVALID	: in std_logic; -- Read valid. This signal indicates that the channel is signaling the required read data.
		M_AXI_RREADY	: out std_logic -- Read ready. This signal indicates that the master can accept the read data and response information.
    );
end load_store_unit;

architecture Behavioral of load_store_unit is
    type ls_state_type is (IDEL, READ_ADDR, READ_DATA, WRITE_ADDR, WRITE_DATA, WRITE_RESP);
    signal state : ls_state_type := IDEL;
    
    signal doing_load : std_logic := '0';
    signal doing_store : std_logic := '0';
    
    -- book-keeping
    signal eyu_inflight : std_logic := '0';
    signal eyu_addr_reg : std_logic_vector(C_M_AXI_ADDR_WIDTH-1 downto 0) := (others=>'0');
    signal eyu_write_done : std_logic :='0';
    signal eyu_load_done : std_logic :='0';
    signal eyu_arvalid : std_logic :='0';
begin

      -- Read Address
  --M_AXI_ARID <= (others => '0');       
  M_AXI_ARLEN <= (others => '0');       
  M_AXI_ARSIZE <= "010";                 
  M_AXI_ARBURST <= "01";                  
  M_AXI_ARLOCK <= '0';                   
  M_AXI_ARCACHE <= "0011";                
  M_AXI_ARPROT <= "000";                 
  M_AXI_ARQOS <= (others => '0');       
  M_AXI_ARUSER <= (others => '0');       

  -- Write channels 
  M_AXI_AWID <= (others => '0');
  M_AXI_AWADDR <= (others => '0');
  M_AXI_AWLEN <= (others => '0');
  M_AXI_AWSIZE <= "010";        
  M_AXI_AWBURST <= "01";
  M_AXI_AWLOCK <= '0';
  M_AXI_AWCACHE <= "0011";
  M_AXI_AWPROT <= "000";
  M_AXI_AWQOS <= (others => '0');
  M_AXI_AWUSER <= (others => '0');
  M_AXI_AWVALID <= '0';          
  M_AXI_WDATA <= (others => '0');
  M_AXI_WSTRB <= (others => '0');
  M_AXI_WLAST <= '0';
  M_AXI_WUSER <= (others => '0');
  M_AXI_WVALID <= '0';
  M_AXI_BREADY <= '1';         
  M_AXI_ARVALID <= eyu_arvalid;
  
  Load_Process: process(M_AXI_ACLK) is
  begin
      if rising_edge(M_AXI_ACLK) then
          if M_AXI_ARESETN = '1' then
              state <= IDEL;
              M_AXI_ARVALID <= '0';
              M_AXI_WVALID <= '0';
              M_AXI_RREADY <= '0';
              M_AXI_AWVALID <= '0';
              M_AXI_BREADY <= '0';
              doing_load <='0';
              doing_store <= '0';
              ls_ready <= '0';
          end if;
          
          case state is 
              when IDEL => 
              ls_ready <= '0';
              if start_load = '1' then
                 doing_load <= '1';
                 doing_store <= '0';
                 M_AXI_ARADDR <= address;
                 M_AXI_ARVALID <= '1';
                 M_AXI_RREADY <= '0';
                 state <= READ_ADDR;
      
              elsif Start_store = '1' then
                 doing_load <= '0';
                 doing_store <= '1';
                 M_AXI_AWADDR <= address;
                 M_AXI_AWVALID <= '1';
                 
                 -- store the data
                 M_AXI_WDATA <= store_data;
                 
                 case func3 is
                     when "010" => M_AXI_WSTRB <= "1111";
                     when "000" => M_AXI_WSTRB <= "0001";
                     when "001" => M_AXI_WSTRB <= "0010";
                 end case;
                 
                 M_AXI_WLAST <= '1';
                 M_AXI_WVALID <='0';
                 M_AXI_BREADY <= '0';  
              
              end if;
              
              
              -- this one is for read data
              when READ_DATA => 
              if M_AXI_RVALID = '1' then
                  load_data <= M_AXI_RDATA;
                  if M_AXI_RLAST = '1' then
                      M_AXI_RREADY <= '0';
                      ls_ready <= '1';
                      state <= idel;
                  end if;
              end if;
              
              -- write address 
              when WRITE_ADDR =>
              if M_AXI_AWREADY = '1' then
                   M_AXI_AWVALID <='0';
                   M_AXI_WVALID <= '1';
                   state <= WRITE_DATA;
              end if;
              
              -- write data
              when WRITE_DATA => 
              if M_AXI_WREADY = '1' then
                  M_AXI_WVALID <= '0';
                  M_AXI_BREADY <= '1';
                  state <= WRITE_RESP;
              end if;
              
              when WRITE_RESP =>
              if M_AXI_BVALID = '1' then
                   M_AXI_BREADY <='0';
                   ls_ready <= '1';
                   state <= idel;
              end if;

          
          end case;
      end if;
  end process Load_Process;


end Behavioral;


























