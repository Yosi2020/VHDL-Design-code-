library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

-- Testbench has no ports
entity eyu_fetch_tb is
end eyu_fetch_tb;

architecture sim of eyu_fetch_tb is
  ------------------------------------------------------------------
  -- clock / reset
  ------------------------------------------------------------------
  constant EYU_TCK : time := 10 ns;         -- 100 MHz
  signal eyu_clk    : std_logic := '0';
  signal eyu_resetn : std_logic := '0';     -- active-low

  ------------------------------------------------------------------
  -- fetch <-> tb
  ------------------------------------------------------------------
  signal eyu_start_read : std_logic := '0';
  signal eyu_read_addr  : std_logic_vector(31 downto 0) := (others=>'0');
  signal eyu_read_done  : std_logic;
  signal eyu_read_data  : std_logic_vector(31 downto 0);

  ------------------------------------------------------------------
  -- AXI link between fetch and ROM (read-only)
  ------------------------------------------------------------------
  signal eyu_araddr  : std_logic_vector(31 downto 0);
  signal eyu_arvalid : std_logic;
  signal eyu_arready : std_logic;
  signal eyu_rdata   : std_logic_vector(31 downto 0);
  signal eyu_rvalid  : std_logic;
  signal eyu_rready  : std_logic;
  signal eyu_rlast   : std_logic;
begin
  ------------------------------------------------------------------
  -- clock / reset generators
  ------------------------------------------------------------------
  eyu_clk <= not eyu_clk after EYU_TCK/2;

  process
  begin
    eyu_resetn <= '0';
    wait for 100 ns;
    eyu_resetn <= '1';
    wait;
  end process;

  ------------------------------------------------------------------
  -- DUT #1: your FETCH unit (rename entity if yours differs)
  -- If your fetch entity is called 'entity_name', replace
  -- 'eyu_fetch_unit_axi' with 'entity work.entity_name' and
  -- keep the same port tying for AR/R channels.
  ------------------------------------------------------------------
  U_IF: entity work.eyu_fetch_unit_axi
    port map (
      eyu_clk        => eyu_clk,
      eyu_resetn     => eyu_resetn,
      eyu_start_read => eyu_start_read,
      eyu_read_addr  => eyu_read_addr,
      eyu_read_done  => eyu_read_done,
      eyu_read_data  => eyu_read_data,

      eyu_M_AXI_ARADDR  => eyu_araddr,
      eyu_M_AXI_ARLEN   => open,           -- sidebands are driven inside fetch
      eyu_M_AXI_ARSIZE  => open,
      eyu_M_AXI_ARBURST => open,
      eyu_M_AXI_ARLOCK  => open,
      eyu_M_AXI_ARCACHE => open,
      eyu_M_AXI_ARPROT  => open,
      eyu_M_AXI_ARQOS   => open,
      eyu_M_AXI_ARVALID => eyu_arvalid,
      eyu_M_AXI_ARREADY => eyu_arready,

      eyu_M_AXI_RDATA   => eyu_rdata,
      eyu_M_AXI_RRESP   => open,
      eyu_M_AXI_RLAST   => eyu_rlast,
      eyu_M_AXI_RVALID  => eyu_rvalid,
      eyu_M_AXI_RREADY  => eyu_rready
    );

  ------------------------------------------------------------------
  -- DUT #2: your ROM model (the one you just fixed)
  ------------------------------------------------------------------
  U_ROM: entity work.rom_model
    generic map (
      eyu_addr_width     => 32,
      eyu_data_width     => 32,
      eyu_mem_depth_word => 1024
    )
    port map (
      eyu_aclk      => eyu_clk,
      eyu_aresetn   => eyu_resetn,
      eyu_s_araddr  => eyu_araddr,
      eyu_s_arvalid => eyu_arvalid,
      eyu_s_arready => eyu_arready,
      eyu_s_rdata   => eyu_rdata,
      eyu_s_rresp   => open,    -- not used by fetch TB
      eyu_s_rlast   => eyu_rlast,
      eyu_s_rvalid  => eyu_rvalid,
      eyu_s_rready  => eyu_rready
    );

  ------------------------------------------------------------------
  -- stimulus: kick one fetch at address 0, then check first word
  ------------------------------------------------------------------
  process
  begin
    -- wait for reset release
    wait until eyu_resetn = '1';
    wait for 40 ns;

    -- start one read at 0x00000000
    eyu_read_addr  <= x"00000000";
    eyu_start_read <= '1';
    wait until rising_edge(eyu_clk);
    eyu_start_read <= '0';

    -- wait for the fetch to complete
    wait until eyu_read_done = '1';

    -- the first word in your ROM init is x"93021000" (check rom_model)
    assert eyu_read_data = x"93021000"
      report "FETCH mismatch: expected 0x93021000, got " & to_hstring(eyu_read_data)
      severity failure;

    report "eyu_fetch_unit_axi PASS âœ…" severity note;
    wait for 50 ns;
    std.env.stop;
  end process;
end architecture;
