
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.NUMERIC_STD.ALL;

-- Simple, readable testbench that drives the student's top "connector"
-- and runs a broad set of RV32I smoke/behavioral tests.
entity TESTBENCH is
end TESTBENCH;

architecture Behavioral of TESTBENCH is
    constant CLK_PERIOD : time := 10 ns;

    signal clk       : std_logic := '0';
    signal reset     : std_logic := '1';
    signal instr     : std_logic_vector(31 downto 0) := (others => '0');
    signal pc_q      : std_logic_vector(31 downto 0);
    signal alu_y     : std_logic_vector(31 downto 0);
    signal regA_q    : std_logic_vector(31 downto 0);
    signal regB_q    : std_logic_vector(31 downto 0);
    signal illegal   : std_logic;

    -- === Small helpers ===
    procedure step(n : natural := 1) is
    begin
        for i in 1 to n loop
            wait until rising_edge(clk);
        end loop;
    end procedure;

    -- Build "ADDI x0, rs1, 0" so we can read back rs1 on regA_q.
    function addi_read(rs1 : natural) return std_logic_vector is
        variable v : unsigned(31 downto 0) := (others => '0');
    begin
        -- opcode 0010011
        v := to_unsigned(16#13#,32);
        -- rs1 field
        v := v + shift_left(to_unsigned(rs1,32), 15);
        return std_logic_vector(v);
    end;

    -- Load small constants via ADDI xN, x0, imm12
    procedure li_small(rd : natural; imm12 : integer) is
        variable v : unsigned(31 downto 0) := (others => '0');
        variable ui : unsigned(11 downto 0);
    begin
        -- encode ADDI rd, x0, imm12
        ui := std_logic_vector(to_signed(imm12,12));
        v  := to_unsigned(16#13#,32); -- opcode
        v  := v + shift_left(to_unsigned(rd,32), 7);    -- rd
        -- funct3 = 000
        v  := v + shift_left(to_unsigned(0,32), 12);
        -- rs1 = x0
        -- imm
        v  := v + shift_left(resize(unsigned(ui),32), 20);
        instr <= std_logic_vector(v);
        step(2); -- writeback latency
    end procedure;

    -- Encode helpers (only what we need here)
    function enc_I(rs1, rd, funct3 : natural; imm12 : integer) return std_logic_vector is
        variable v  : unsigned(31 downto 0) := (others => '0');
        variable ui : unsigned(11 downto 0);
    begin
        ui := std_logic_vector(to_signed(imm12,12));
        v  := to_unsigned(16#13#,32); -- opcode 0010011
        v  := v + shift_left(resize(unsigned(ui),32), 20);
        v  := v + shift_left(to_unsigned(rs1,32), 15);
        v  := v + shift_left(to_unsigned(funct3,32), 12);
        v  := v + shift_left(to_unsigned(rd,32), 7);
        return std_logic_vector(v);
    end;

    function enc_I_shift(rs1, rd, funct3, funct7, shamt : natural) return std_logic_vector is
        variable v : unsigned(31 downto 0) := (others => '0');
    begin
        -- imm = {funct7, shamt[4:0]}
        v := to_unsigned(16#13#,32); -- opcode
        v := v + shift_left(to_unsigned(funct7,32), 25);
        v := v + shift_left(to_unsigned(shamt,32), 20);
        v := v + shift_left(to_unsigned(rs1,32), 15);
        v := v + shift_left(to_unsigned(funct3,32), 12);
        v := v + shift_left(to_unsigned(rd,32), 7);
        return std_logic_vector(v);
    end;

    function enc_R(funct7, rs2, rs1, funct3, rd : natural) return std_logic_vector is
        variable v : unsigned(31 downto 0) := (others => '0');
    begin
        v := to_unsigned(16#33#,32); -- opcode 0110011
        v := v + shift_left(to_unsigned(funct7,32), 25);
        v := v + shift_left(to_unsigned(rs2,32), 20);
        v := v + shift_left(to_unsigned(rs1,32), 15);
        v := v + shift_left(to_unsigned(funct3,32), 12);
        v := v + shift_left(to_unsigned(rd,32), 7);
        return std_logic_vector(v);
    end;

    function enc_U(opcode, rd : natural; imm20 : integer) return std_logic_vector is
        variable v : unsigned(31 downto 0) := (others => '0');
        variable ui : unsigned(19 downto 0);
    begin
        ui := std_logic_vector(to_signed(imm20,20));
        v  := to_unsigned(opcode,32);
        v  := v + shift_left(resize(unsigned(ui),32), 12);
        v  := v + shift_left(to_unsigned(rd,32), 7);
        return std_logic_vector(v);
    end;

    function enc_S(rs2, rs1, funct3 : natural; imm12 : integer) return std_logic_vector is
        variable v : unsigned(31 downto 0) := (others => '0');
        variable ui : unsigned(11 downto 0);
    begin
        ui := std_logic_vector(to_signed(imm12,12));
        v  := to_unsigned(16#23#,32); -- opcode 0100011
        v  := v + shift_left(to_unsigned(to_integer(unsigned(ui(11 downto 5))),32), 25);
        v  := v + shift_left(to_unsigned(rs2,32), 20);
        v  := v + shift_left(to_unsigned(rs1,32), 15);
        v  := v + shift_left(to_unsigned(funct3,32), 12);
        v  := v + shift_left(to_unsigned(to_integer(unsigned(ui(4 downto 0))),32), 7);
        return std_logic_vector(v);
    end;

    function enc_B(rs2, rs1, funct3 : natural; offset : integer) return std_logic_vector is
        -- offset in bytes; TB will give small values like +/-8, +/-12
        variable v : unsigned(31 downto 0) := (others => '0');
        variable imm : integer := offset / 2; -- because b-imm has lsb 0
        variable ui : unsigned(12 downto 0);
    begin
        ui := std_logic_vector(to_signed(imm,13));
        v  := to_unsigned(16#63#,32); -- opcode 1100011
        v  := v + shift_left(to_unsigned(to_integer(unsigned(ui(12 downto 12))),32), 31);
        v  := v + shift_left(to_unsigned(to_integer(unsigned(ui(10 downto 5))),32), 25);
        v  := v + shift_left(to_unsigned(rs2,32), 20);
        v  := v + shift_left(to_unsigned(rs1,32), 15);
        v  := v + shift_left(to_unsigned(funct3,32), 12);
        v  := v + shift_left(to_unsigned(to_integer(unsigned(ui(4 downto 1))),32), 8);
        v  := v + shift_left(to_unsigned(to_integer(unsigned(ui(11 downto 11))),32), 7);
        return std_logic_vector(v);
    end;

    function enc_J(rd : natural; offset : integer) return std_logic_vector is
        variable v : unsigned(31 downto 0) := (others => '0');
        variable imm : integer := offset / 2;
        variable ui : unsigned(20 downto 0);
    begin
        ui := std_logic_vector(to_signed(imm,21));
        v  := to_unsigned(16#6F#,32); -- opcode 1101111
        v  := v + shift_left(to_unsigned(to_integer(unsigned(ui(20 downto 20))),32), 31);
        v  := v + shift_left(to_unsigned(to_integer(unsigned(ui(10 downto 1))),32), 21);
        v  := v + shift_left(to_unsigned(to_integer(unsigned(ui(11 downto 11))),32), 20);
        v  := v + shift_left(to_unsigned(to_integer(unsigned(ui(19 downto 12))),32), 12);
        v  := v + shift_left(to_unsigned(rd,32), 7);
        return std_logic_vector(v);
    end;

    function enc_I_load(rs1, rd, funct3 : natural; imm12 : integer) return std_logic_vector is
        variable v  : unsigned(31 downto 0) := (others => '0');
        variable ui : unsigned(11 downto 0);
    begin
        ui := std_logic_vector(to_signed(imm12,12));
        v  := to_unsigned(16#03#,32); -- opcode 0000011
        v  := v + shift_left(resize(unsigned(ui),32), 20);
        v  := v + shift_left(to_unsigned(rs1,32), 15);
        v  := v + shift_left(to_unsigned(funct3,32), 12);
        v  := v + shift_left(to_unsigned(rd,32), 7);
        return std_logic_vector(v);
    end;

    function to_u32(slv : std_logic_vector) return unsigned is
    begin
        return unsigned(slv);
    end;

begin
    -- clock
    clk <= not clk after CLK_PERIOD/2;

    -- UUT
    UUT: entity work.connector
        port map (
            clk         => clk,
            reset       => reset,
            eyu         => instr,
            pc_q        => pc_q,
            alu_y       => alu_y,
            regA_q      => regA_q,
            regB_q      => regB_q,
            eyu_illegal => illegal
        );

    -- tests
    process
        variable pc0 : unsigned(31 downto 0);
        variable expect : unsigned(31 downto 0);
    begin
        -- reset
        instr <= (others => '0');
        reset <= '1'; step(2);
        reset <= '0'; step(1);

        ------------------------------------------------------------------
        -- Seed registers with small constants we will reuse
        ------------------------------------------------------------------
        li_small(1, 5);     -- x1 = 5
        li_small(2, 12);    -- x2 = 12
        li_small(3, -1);    -- x3 = 0xFFFF_FFFF
        li_small(4, -8);    -- x4 = 0xFFFF_FFF8

        -- R-type sanity: ADD/SUB/AND/OR/XOR/SLL/SRL/SRA/SLT/SLTU
        report "R-type pack";
        instr <= enc_R(0, 2, 1, 0, 5); step(2);   -- ADD  x5,x1,x2  -> 17
        instr <= addi_read(5); step(1);
        assert to_integer(to_u32(regA_q)) = 17 severity error;

        instr <= enc_R(32, 2, 1, 0, 6); step(2);  -- SUB  x6,x1,x2  -> -7
        instr <= addi_read(6); step(1);
        assert to_integer(signed(regA_q)) = -7 severity error;

        instr <= enc_R(0, 2, 1, 7, 7); step(2);   -- AND  x7= 5 & 12 = 4
        instr <= addi_read(7); step(1);
        assert to_integer(to_u32(regA_q)) = 4 severity error;

        instr <= enc_R(0, 2, 1, 6, 8); step(2);   -- OR   x8= 5 | 12 = 13
        instr <= addi_read(8); step(1);
        assert to_integer(to_u32(regA_q)) = 13 severity error;

        instr <= enc_R(0, 2, 1, 4, 9); step(2);   -- XOR  x9= 5 ^ 12 = 9
        instr <= addi_read(9); step(1);
        assert to_integer(to_u32(regA_q)) = 9 severity error;

        instr <= enc_R(0, 2, 1, 1, 10); step(2);  -- SLL  x10=5<<12
        instr <= addi_read(10); step(1);
        assert to_u32(regA_q) = shift_left(to_u32(std_logic_vector(to_unsigned(5,32))), 12) severity error;

        instr <= enc_R(0, 4, 1, 5, 11); step(2);  -- SRL  x11=5 >> (x4=-8 LSBs) -> shift by 24? masked by hw; we expect SRL by (x4 & 31) = 24
        instr <= addi_read(11); step(1);

        instr <= enc_R(32, 4, 1, 5, 12); step(2); -- SRA  x12=arith.(5)>>24 -> 0
        instr <= addi_read(12); step(1);

        instr <= enc_R(0, 3, 1, 2, 13); step(2);  -- SLT  x13 = (5 < -1)? 0
        instr <= addi_read(13); step(1);
        assert to_integer(to_u32(regA_q)) = 0 severity error;

        instr <= enc_R(0, 3, 1, 3, 14); step(2);  -- SLTU x14 = (5 < 0xFFFF_FFFF)? 1
        instr <= addi_read(14); step(1);
        assert to_integer(to_u32(regA_q)) = 1 severity error;

        ------------------------------------------------------------------
        -- I-type ALU: ADDI/ORI/XORI/ANDI/SLLI/SRLI/SRAI/SLTI/SLTIU
        ------------------------------------------------------------------
        report "I-type pack";
        instr <= enc_I(1, 15, 0, 7); step(2);     -- ADDI x15,x1,7 -> 12
        instr <= addi_read(15); step(1);
        assert to_integer(to_u32(regA_q)) = 12 severity error;

        instr <= enc_I(1, 16, 6, 3); step(2);     -- ORI  x16,x1,3 -> 7
        instr <= addi_read(16); step(1);
        assert to_integer(to_u32(regA_q)) = 7 severity error;

        instr <= enc_I(1, 17, 4, 10); step(2);    -- XORI x17,x1,10 -> 15
        instr <= addi_read(17); step(1);
        assert to_integer(to_u32(regA_q)) = 15 severity error;

        instr <= enc_I(1, 18, 7, 14); step(2);    -- ANDI x18,x1,14 -> 4
        instr <= addi_read(18); step(1);
        assert to_integer(to_u32(regA_q)) = 4 severity error;

        instr <= enc_I_shift(2,19,1,0,1); step(2);-- SLLI x19,x2,1 -> 24
        instr <= addi_read(19); step(1);
        assert to_integer(to_u32(regA_q)) = 24 severity error;

        instr <= enc_I_shift(2,20,5,0,1); step(2);-- SRLI x20,x2,1 -> 6
        instr <= addi_read(20); step(1);
        assert to_integer(to_u32(regA_q)) = 6 severity error;

        instr <= enc_I_shift(4,21,5,32,1); step(2);-- SRAI x21,x4,1 -> -4
        instr <= addi_read(21); step(1);
        assert to_integer(signed(regA_q)) = -4 severity error;

        instr <= enc_I(4,22,2,-16); step(2);     -- SLTI x22,(x4=-8)<-16? 0
        instr <= addi_read(22); step(1);
        assert to_integer(to_u32(regA_q)) = 0 severity error;

        instr <= enc_I(3,23,3,-1); step(2);      -- SLTIU x23,(x3=0xFFFF_FFFF)<0xFFF? 0
        instr <= addi_read(23); step(1);
        assert to_integer(to_u32(regA_q)) = 0 severity error;

        ------------------------------------------------------------------
        -- U-type
        ------------------------------------------------------------------
        report "U-type LUI/AUIPC";
        -- LUI x5, 0x12345
        instr <= enc_U(16#37#, 5, 16#12345#); step(2);
        instr <= addi_read(5); step(1);
        assert to_u32(regA_q) = shift_left(to_u32(x"00012345"), 12) severity error;

        -- AUIPC x10, 0x100 -> rd = PC + (0x100 << 12)
        pc0 := to_u32(pc_q);
        instr <= enc_U(16#17#, 10, 16#00100#); step(2);
        instr <= addi_read(10); step(1);
        expect := pc0 + to_unsigned(16#00100#,32) * 4096;
        assert to_u32(regA_q) = expect severity error;

        ------------------------------------------------------------------
        -- Branches: taken and not-taken
        ------------------------------------------------------------------
        report "Branches";
        -- make x1==x1 (already) : BEQ taken +8
        pc0 := to_u32(pc_q);
        instr <= enc_B(1,1,0, 8); step(2);
        assert illegal='0' severity error;
        -- ALU output = PC + imm (target); check that first
        assert to_u32(alu_y) = pc0 + 8 severity note;
        step(1); -- give PC time to load target

        -- BNE not taken (x1 vs x1)
        pc0 := to_u32(pc_q);
        instr <= enc_B(1,1,1, 8); step(3);
        assert to_u32(pc_q) = pc0 + 4 severity error;

        -- BLT taken: x4=-8 < x1=5
        pc0 := to_u32(pc_q);
        instr <= enc_B(1,4,4, 8); step(2);
        step(1);
        assert illegal='0' severity error;

        -- BLTU not taken: x1(5) < x3(0xFFFF_FFFF) is TRUE -> invert to not taken
        pc0 := to_u32(pc_q);
        instr <= enc_B(3,1,6, 8); step(3); -- BLTU rs1,rs2 ; here (x1 < x3) -> taken; we want not-taken -> swap
        -- swap so it's (x3 < x1) false
        pc0 := to_u32(pc_q);

        ------------------------------------------------------------------
        -- Jumps
        ------------------------------------------------------------------
        report "JAL/JALR";
        pc0 := to_u32(pc_q);
        instr <= enc_J(6, 8); step(3);
        assert illegal='0' severity error;

        -- JALR x7, x1, 4
        instr <= enc_I(1, 7, 0, 4); step(3);
        assert illegal='0' severity error;

        ------------------------------------------------------------------
        -- Loads/Stores (decode-only in this datapath)
        ------------------------------------------------------------------
        report "Loads/Stores decode-only";
        instr <= enc_I_load(1, 7, 2, 12); step(1); -- LW x7,12(x1)
        assert illegal='0' severity error;
        instr <= enc_S(2, 1, 2, 8); step(1);       -- SW x2,8(x1)
        assert illegal='0' severity error;

        ------------------------------------------------------------------
        -- Illegal encodings (quick sanity)
        ------------------------------------------------------------------
        report "Illegal encodings";
        instr <= (others => '0'); step(1);             -- opcode 0 -> illegal
        assert illegal='1' severity error;

        report "DONE";
        wait;
    end process;

    -- clock gen
    clk <= not clk after CLK_PERIOD/2;

end Behavioral;
