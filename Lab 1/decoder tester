
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.NUMERIC_STD.ALL;

-- Simple, human-written testbench for the student's top "connector".
-- Uses eyu/eyosi-style names and runs a compact but broad set of RV32I checks.
entity TESTBENCH_EYU is
end TESTBENCH_EYU;

architecture sim of TESTBENCH_EYU is
    constant EYU_T : time := 10 ns;

    signal eyu_clk     : std_logic := '0';
    signal eyu_reset   : std_logic := '1';
    signal eyu_instr   : std_logic_vector(31 downto 0) := (others => '0');
    signal eyu_pc_q    : std_logic_vector(31 downto 0);
    signal eyu_alu_y   : std_logic_vector(31 downto 0);
    signal eyosi_A_q   : std_logic_vector(31 downto 0);
    signal eyosi_B_q   : std_logic_vector(31 downto 0);
    signal eyu_bad     : std_logic;

    -- step N clocks
    procedure eyu_step(n : natural := 1) is
    begin
        for i in 1 to n loop
            wait until rising_edge(eyu_clk);
        end loop;
    end procedure;

    function u32(slv : std_logic_vector) return unsigned is
    begin
        return unsigned(slv);
    end function;

    -- ==== Encoders (return a 32-bit instruction) ====

    -- Seed regs: ADDI rd, x0, imm12
    function enc_addi_x0(rd : natural; imm12 : integer) return std_logic_vector is
        variable v  : unsigned(31 downto 0) := (others => '0');
        variable ui : signed(11 downto 0);
    begin
        ui := to_signed(imm12, 12);
        v  := to_unsigned(16#13#, 32);                                -- opcode 0010011
        v  := v + shift_left(to_unsigned(rd, 32), 7);                  -- rd
        v  := v + shift_left(to_unsigned(0, 32), 12);                  -- funct3=000
        v  := v + shift_left(resize(unsigned(ui), 32), 20);            -- imm
        -- rs1 = x0
        return std_logic_vector(v);
    end function;

    -- Peek rs1 on A-bus without changing state: ADDI x0, rs1, 0
    function enc_addi_read(rs1 : natural) return std_logic_vector is
        variable v : unsigned(31 downto 0) := (others => '0');
    begin
        v := to_unsigned(16#13#, 32);                    -- opcode 0010011
        v := v + shift_left(to_unsigned(rs1, 32), 15);   -- rs1 field
        -- rd=0, funct3=000, imm=0 stay 0
        return std_logic_vector(v);
    end function;

    -- I-type
    function enc_I(rs1, rd, funct3 : natural; imm12 : integer) return std_logic_vector is
        variable v  : unsigned(31 downto 0) := (others => '0');
        variable ui : signed(11 downto 0);
    begin
        ui := to_signed(imm12, 12);
        v  := to_unsigned(16#13#, 32);
        v  := v + shift_left(resize(unsigned(ui), 32), 20);
        v  := v + shift_left(to_unsigned(rs1, 32), 15);
        v  := v + shift_left(to_unsigned(funct3, 32), 12);
        v  := v + shift_left(to_unsigned(rd, 32), 7);
        return std_logic_vector(v);
    end function;

    -- I-type shifts (SLLI/SRLI/SRAI)
    function enc_I_shift(rs1, rd, funct3, funct7, shamt : natural) return std_logic_vector is
        variable v   : unsigned(31 downto 0) := (others => '0');
        constant sh5 : natural := shamt mod 32;
    begin
        v := to_unsigned(16#13#, 32);
        v := v + shift_left(to_unsigned(funct7, 32), 25);
        v := v + shift_left(to_unsigned(sh5,   32), 20);
        v := v + shift_left(to_unsigned(rs1,   32), 15);
        v := v + shift_left(to_unsigned(funct3,32), 12);
        v := v + shift_left(to_unsigned(rd,    32), 7);
        return std_logic_vector(v);
    end function;

    -- R-type
    function enc_R(funct7, rs2, rs1, funct3, rd : natural) return std_logic_vector is
        variable v : unsigned(31 downto 0) := (others => '0');
    begin
        v := to_unsigned(16#33#, 32);
        v := v + shift_left(to_unsigned(funct7, 32), 25);
        v := v + shift_left(to_unsigned(rs2,   32), 20);
        v := v + shift_left(to_unsigned(rs1,   32), 15);
        v := v + shift_left(to_unsigned(funct3,32), 12);
        v := v + shift_left(to_unsigned(rd,    32), 7);
        return std_logic_vector(v);
    end function;

    -- U-type (LUI/AUIPC): imm20 will be placed at [31:12]
    function enc_U(opcode, rd : natural; imm20 : integer) return std_logic_vector is
        variable v  : unsigned(31 downto 0) := (others => '0');
        variable ui : signed(19 downto 0);
    begin
        ui := to_signed(imm20, 20);
        v  := to_unsigned(opcode, 32);
        v  := v + shift_left(resize(unsigned(ui), 32), 12);
        v  := v + shift_left(to_unsigned(rd, 32), 7);
        return std_logic_vector(v);
    end function;

    -- S-type (stores)
    function enc_S(rs2, rs1, funct3 : natural; imm12 : integer) return std_logic_vector is
        variable v  : unsigned(31 downto 0) := (others => '0');
        variable ui : signed(11 downto 0);
    begin
        ui := to_signed(imm12, 12);
        v  := to_unsigned(16#23#, 32);  -- 0100011
        v  := v + shift_left(resize(unsigned(ui(11 downto 5)), 32), 25);
        v  := v + shift_left(to_unsigned(rs2, 32), 20);
        v  := v + shift_left(to_unsigned(rs1, 32), 15);
        v  := v + shift_left(to_unsigned(funct3, 32), 12);
        v  := v + shift_left(resize(unsigned(ui(4 downto 0)), 32), 7);
        return std_logic_vector(v);
    end function;

    -- B-type (branches). offset in BYTES. LSB forced 0 in encoding.
    function enc_B(rs2, rs1, funct3 : natural; offset_bytes : integer) return std_logic_vector is
        variable v  : unsigned(31 downto 0) := (others => '0');
        variable imm : integer := offset_bytes / 2;
        variable ui  : signed(12 downto 0);
    begin
        ui := to_signed(imm, 13);
        v  := to_unsigned(16#63#, 32);  -- 1100011
        v  := v + shift_left(to_unsigned(to_integer(unsigned(std_logic_vector(ui(12 downto 12)))), 32), 31); -- imm[12] -> bit31
        v  := v + shift_left(to_unsigned(to_integer(unsigned(std_logic_vector(ui(10 downto 5)))), 32), 25);  -- imm[10:5]
        v  := v + shift_left(to_unsigned(rs2, 32), 20);
        v  := v + shift_left(to_unsigned(rs1, 32), 15);
        v  := v + shift_left(to_unsigned(funct3, 32), 12);
        v  := v + shift_left(to_unsigned(to_integer(unsigned(std_logic_vector(ui(4 downto 1)))), 32), 8);   -- imm[4:1]
        v  := v + shift_left(to_unsigned(to_integer(unsigned(std_logic_vector(ui(11 downto 11)))), 32), 7); -- imm[11]
        return std_logic_vector(v);
    end function;

    -- J-type (jumps). offset in BYTES.
    function enc_J(rd : natural; offset_bytes : integer) return std_logic_vector is
        variable v  : unsigned(31 downto 0) := (others => '0');
        variable imm : integer := offset_bytes / 2;
        variable ui  : signed(20 downto 0);
    begin
        ui := to_signed(imm, 21);
        v  := to_unsigned(16#6F#, 32);  -- 1101111
        v  := v + shift_left(to_unsigned(to_integer(unsigned(std_logic_vector(ui(20 downto 20)))), 32), 31); -- imm[20]
        v  := v + shift_left(to_unsigned(to_integer(unsigned(std_logic_vector(ui(10 downto 1)))), 32), 21);  -- imm[10:1]
        v  := v + shift_left(to_unsigned(to_integer(unsigned(std_logic_vector(ui(11 downto 11)))), 32), 20); -- imm[11]
        v  := v + shift_left(to_unsigned(to_integer(unsigned(std_logic_vector(ui(19 downto 12)))), 32), 12); -- imm[19:12]
        v  := v + shift_left(to_unsigned(rd, 32), 7);
        return std_logic_vector(v);
    end function;

    -- I-type load (e.g., LW)
    function enc_I_load(rs1, rd, funct3 : natural; imm12 : integer) return std_logic_vector is
        variable v  : unsigned(31 downto 0) := (others => '0');
        variable ui : signed(11 downto 0);
    begin
        ui := to_signed(imm12, 12);
        v  := to_unsigned(16#03#, 32);  -- 0000011
        v  := v + shift_left(resize(unsigned(ui), 32), 20);
        v  := v + shift_left(to_unsigned(rs1, 32), 15);
        v  := v + shift_left(to_unsigned(funct3, 32), 12);
        v  := v + shift_left(to_unsigned(rd, 32), 7);
        return std_logic_vector(v);
    end function;

begin
    -- clock
    eyu_clk <= not eyu_clk after EYU_T/2;

    -- UUT
    UUT: entity work.connector
      port map (
        clk         => eyu_clk,
        reset       => eyu_reset,
        eyu         => eyu_instr,
        pc_q        => eyu_pc_q,
        alu_y       => eyu_alu_y,
        regA_q      => eyosi_A_q,
        regB_q      => eyosi_B_q,
        eyu_illegal => eyu_bad
      );

    -- sequence
    process
        variable pc0    : unsigned(31 downto 0);
        variable expect : unsigned(31 downto 0);
    begin
        -- reset
        eyu_instr <= (others => '0');
        eyu_reset <= '1'; eyu_step(2);
        eyu_reset <= '0'; eyu_step(1);

        -- quick sanity on illegal flag
        eyu_instr <= x"00000013"; eyu_step(1);  -- NOP (ADDI x0,x0,0)
        report "NOP illegal=" & std_logic'image(eyu_bad);
        eyu_instr <= (others => '0'); eyu_step(1); -- illegal
        report "ZERO illegal=" & std_logic'image(eyu_bad);

        -- seed a few regs
        eyu_instr <= enc_addi_x0(1, 5);  eyu_step(2);  -- x1=5
        eyu_instr <= enc_addi_x0(2,12);  eyu_step(2);  -- x2=12
        eyu_instr <= enc_addi_x0(3,-1);  eyu_step(2);  -- x3=0xFFFF_FFFF
        eyu_instr <= enc_addi_x0(4,-8);  eyu_step(2);  -- x4=0xFFFF_FFF8

        -- a few R/I/U/branch/jump checks
        eyu_instr <= enc_R(0, 2, 1, 0, 5);  eyu_step(2); eyu_instr <= enc_addi_read(5); eyu_step(1);
        report "ADD x5 = " & integer'image(to_integer(u32(eyosi_A_q)));

        eyu_instr <= enc_I(1, 15, 0, 7);   eyu_step(2); eyu_instr <= enc_addi_read(15); eyu_step(1);
        report "ADDI x15 = " & integer'image(to_integer(u32(eyosi_A_q)));

        eyu_instr <= enc_I_shift(2,19,1,0,1); eyu_step(2); eyu_instr <= enc_addi_read(19); eyu_step(1);
        report "SLLI x19 = " & integer'image(to_integer(u32(eyosi_A_q)));

        eyu_instr <= enc_U(16#37#, 5, 16#12345#); eyu_step(2); eyu_instr <= enc_addi_read(5); eyu_step(1);
        report "LUI x5 = 0x" & integer'image(to_integer(u32(eyosi_A_q)));

        pc0 := u32(eyu_pc_q);
        eyu_instr <= enc_U(16#17#, 10, 16#00100#); eyu_step(2); eyu_instr <= enc_addi_read(10); eyu_step(1);
        expect := pc0 + shift_left(to_unsigned(16#00100#,32), 12);
        report "AUIPC x10 got=" & integer'image(to_integer(u32(eyosi_A_q))) &
               " exp=" & integer'image(to_integer(expect));

        pc0 := u32(eyu_pc_q);
        eyu_instr <= enc_B(1,1,0, 8);  eyu_step(2); eyu_step(1);  -- BEQ taken
        report "BEQ taken? PC moved from " & integer'image(to_integer(pc0)) &
               " to " & integer'image(to_integer(u32(eyu_pc_q)));

        pc0 := u32(eyu_pc_q);
        eyu_instr <= enc_J(6, 8);      eyu_step(3);
        report "JAL PC = " & integer'image(to_integer(u32(eyu_pc_q)));

        eyu_instr <= enc_I(1, 7, 0, 4); eyu_step(3); -- JALR x7,x1,4
        report "JALR PC = " & integer'image(to_integer(u32(eyu_pc_q)));

        -- decode-only mem ops (no memory WB in this datapath)
        eyu_instr <= enc_I_load(1, 7, 2, 12); eyu_step(1);
        eyu_instr <= enc_S(2, 1, 2, 8);       eyu_step(1);

        report "DONE";
        wait;
    end process;
end architecture;
