
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.NUMERIC_STD.ALL;

entity TESTBENCH is
end TESTBENCH;

architecture Behavioral of TESTBENCH is
    constant CLK_PERIOD : time := 10 ns;

    signal clk       : std_logic := '0';
    signal reset     : std_logic := '1';
    signal instr     : std_logic_vector(31 downto 0) := (others => '0');
    signal pc_q      : std_logic_vector(31 downto 0);
    signal alu_y     : std_logic_vector(31 downto 0);
    signal regA_q    : std_logic_vector(31 downto 0);
    signal regB_q    : std_logic_vector(31 downto 0);
    signal illegal   : std_logic;

    -- === Helpers ===
    procedure step(n : natural := 1) is
    begin
        for i in 1 to n loop
            wait until rising_edge(clk);
        end loop;
    end procedure;

    -- Build ADDI rd, x0, imm12 (rs1=0). Returns 32-bit instruction.
    function enc_addi_x0(rd : natural; imm12 : integer) return std_logic_vector is
        variable v  : unsigned(31 downto 0) := (others => '0');
        variable ui : signed(11 downto 0);
    begin
        ui := to_signed(imm12, 12);
        v  := to_unsigned(16#13#, 32);                                -- opcode 0010011
        v  := v + shift_left(to_unsigned(rd, 32), 7);                  -- rd
        v  := v + shift_left(to_unsigned(0, 32), 12);                  -- funct3=000
        v  := v + shift_left(resize(unsigned(ui), 32), 20);            -- imm[11:0]
        -- rs1 is x0 => 0
        return std_logic_vector(v);
    end function;

    -- I-type ALU (generic)
    function enc_I(rs1, rd, funct3 : natural; imm12 : integer) return std_logic_vector is
        variable v  : unsigned(31 downto 0) := (others => '0');
        variable ui : signed(11 downto 0);
    begin
        ui := to_signed(imm12, 12);
        v  := to_unsigned(16#13#, 32);                                 -- opcode 0010011
        v  := v + shift_left(resize(unsigned(ui), 32), 20);            -- imm
        v  := v + shift_left(to_unsigned(rs1, 32), 15);
        v  := v + shift_left(to_unsigned(funct3, 32), 12);
        v  := v + shift_left(to_unsigned(rd, 32), 7);
        return std_logic_vector(v);
    end function;

    -- I-type shifts (SLLI/SRLI/SRAI) with explicit funct7 + shamt
    function enc_I_shift(rs1, rd, funct3, funct7, shamt : natural) return std_logic_vector is
        variable v : unsigned(31 downto 0) := (others => '0');
    begin
        v := to_unsigned(16#13#, 32);                                  -- opcode 0010011
        v := v + shift_left(to_unsigned(funct7, 32), 25);
        v := v + shift_left(to_unsigned(shamt and 31, 32), 20);
        v := v + shift_left(to_unsigned(rs1, 32), 15);
        v := v + shift_left(to_unsigned(funct3, 32), 12);
        v := v + shift_left(to_unsigned(rd, 32), 7);
        return std_logic_vector(v);
    end function;

    -- R-type
    function enc_R(funct7, rs2, rs1, funct3, rd : natural) return std_logic_vector is
        variable v : unsigned(31 downto 0) := (others => '0');
    begin
        v := to_unsigned(16#33#, 32);                                  -- opcode 0110011
        v := v + shift_left(to_unsigned(funct7, 32), 25);
        v := v + shift_left(to_unsigned(rs2, 32), 20);
        v := v + shift_left(to_unsigned(rs1, 32), 15);
        v := v + shift_left(to_unsigned(funct3, 32), 12);
        v := v + shift_left(to_unsigned(rd, 32), 7);
        return std_logic_vector(v);
    end function;

    -- U-type (LUI/AUIPC): imm20 is the 20 MSBs (signed only affects display; hardware uses raw bits)
    function enc_U(opcode, rd : natural; imm20 : integer) return std_logic_vector is
        variable v  : unsigned(31 downto 0) := (others => '0');
        variable ui : signed(19 downto 0);
    begin
        ui := to_signed(imm20, 20);
        v  := to_unsigned(opcode, 32);
        v  := v + shift_left(resize(unsigned(ui), 32), 12);
        v  := v + shift_left(to_unsigned(rd, 32), 7);
        return std_logic_vector(v);
    end function;

    -- S-type (stores)
    function enc_S(rs2, rs1, funct3 : natural; imm12 : integer) return std_logic_vector is
        variable v  : unsigned(31 downto 0) := (others => '0');
        variable ui : signed(11 downto 0);
    begin
        ui := to_signed(imm12, 12);
        v  := to_unsigned(16#23#, 32);                                 -- opcode 0100011
        v  := v + shift_left(resize(unsigned(ui(11 downto 5)), 32), 25);
        v  := v + shift_left(to_unsigned(rs2, 32), 20);
        v  := v + shift_left(to_unsigned(rs1, 32), 15);
        v  := v + shift_left(to_unsigned(funct3, 32), 12);
        v  := v + shift_left(resize(unsigned(ui(4 downto 0)), 32), 7);
        return std_logic_vector(v);
    end function;

    -- B-type (branches). offset is in BYTES; lower bit is forced 0 by encoding.
    function enc_B(rs2, rs1, funct3 : natural; offset : integer) return std_logic_vector is
        variable v  : unsigned(31 downto 0) := (others => '0');
        variable imm : integer := offset / 2;                           -- because b-imm has LSB 0
        variable ui  : signed(12 downto 0);
    begin
        ui := to_signed(imm, 13);
        v  := to_unsigned(16#63#, 32);                                  -- opcode 1100011
        v  := v + shift_left(to_unsigned(to_integer(unsigned(std_logic_vector(ui(12 downto 12)))), 32), 31);
        v  := v + shift_left(to_unsigned(to_integer(unsigned(std_logic_vector(ui(10 downto 5)))), 32), 25);
        v  := v + shift_left(to_unsigned(rs2, 32), 20);
        v  := v + shift_left(to_unsigned(rs1, 32), 15);
        v  := v + shift_left(to_unsigned(funct3, 32), 12);
        v  := v + shift_left(to_unsigned(to_integer(unsigned(std_logic_vector(ui(4 downto 1)))), 32), 8);
        v  := v + shift_left(to_unsigned(to_integer(unsigned(std_logic_vector(ui(11 downto 11)))), 32), 7);
        return std_logic_vector(v);
    end function;

    -- J-type (jumps). offset in BYTES; LSB forced 0.
    function enc_J(rd : natural; offset : integer) return std_logic_vector is
        variable v  : unsigned(31 downto 0) := (others => '0');
        variable imm : integer := offset / 2;
        variable ui  : signed(20 downto 0);
    begin
        ui := to_signed(imm, 21);
        v  := to_unsigned(16#6F#, 32);                                  -- opcode 1101111
        v  := v + shift_left(to_unsigned(to_integer(unsigned(std_logic_vector(ui(20 downto 20)))), 32), 31);
        v  := v + shift_left(to_unsigned(to_integer(unsigned(std_logic_vector(ui(10 downto 1)))), 32), 21);
        v  := v + shift_left(to_unsigned(to_integer(unsigned(std_logic_vector(ui(11 downto 11)))), 32), 20);
        v  := v + shift_left(to_unsigned(to_integer(unsigned(std_logic_vector(ui(19 downto 12)))), 32), 12);
        v  := v + shift_left(to_unsigned(rd, 32), 7);
        return std_logic_vector(v);
    end function;

    -- I-type loads (e.g., LW)
    function enc_I_load(rs1, rd, funct3 : natural; imm12 : integer) return std_logic_vector is
        variable v  : unsigned(31 downto 0) := (others => '0');
        variable ui : signed(11 downto 0);
    begin
        ui := to_signed(imm12, 12);
        v  := to_unsigned(16#03#, 32);                                  -- opcode 0000011
        v  := v + shift_left(resize(unsigned(ui), 32), 20);
        v  := v + shift_left(to_unsigned(rs1, 32), 15);
        v  := v + shift_left(to_unsigned(funct3, 32), 12);
        v  := v + shift_left(to_unsigned(rd, 32), 7);
        return std_logic_vector(v);
    end function;

    function to_u32(slv : std_logic_vector) return unsigned is
    begin
        return unsigned(slv);
    end function;

begin
    -- clock
    clk <= not clk after CLK_PERIOD/2;

    -- UUT
    UUT: entity work.connector
        port map (
            clk         => clk,
            reset       => reset,
            eyu         => instr,
            pc_q        => pc_q,
            alu_y       => alu_y,
            regA_q      => regA_q,
            regB_q      => regB_q,
            eyu_illegal => illegal
        );

    -- Stimulus
    process
        variable pc0    : unsigned(31 downto 0);
        variable expect : unsigned(31 downto 0);
    begin
        -- Reset
        instr <= (others => '0');
        reset <= '1'; step(2);
        reset <= '0'; step(1);

        -- Seed some regs via ADDI xN, x0, imm
        instr <= enc_addi_x0(1, 5);  step(2);  -- x1 = 5
        instr <= enc_addi_x0(2, 12); step(2);  -- x2 = 12
        instr <= enc_addi_x0(3, -1); step(2);  -- x3 = 0xFFFF_FFFF
        instr <= enc_addi_x0(4, -8); step(2);  -- x4 = 0xFFFF_FFF8

        -- R-type
        instr <= enc_R(0, 2, 1, 0, 5);  step(2); instr <= enc_addi_x0(0, 0); step(1); -- read x5 via regA_q
        assert to_integer(to_u32(regA_q)) = 17 severity error;

        instr <= enc_R(32,2, 1, 0, 6);  step(2); instr <= enc_addi_x0(0, 0); step(1);
        assert to_integer(signed(regA_q)) = -7 severity error;

        instr <= enc_R(0, 2, 1, 7, 7);  step(2); instr <= enc_addi_x0(0, 0); step(1);
        assert to_integer(to_u32(regA_q)) = 4 severity error;

        instr <= enc_R(0, 2, 1, 6, 8);  step(2); instr <= enc_addi_x0(0, 0); step(1);
        assert to_integer(to_u32(regA_q)) = 13 severity error;

        instr <= enc_R(0, 2, 1, 4, 9);  step(2); instr <= enc_addi_x0(0, 0); step(1);
        assert to_integer(to_u32(regA_q)) = 9 severity error;

        instr <= enc_R(0, 2, 1, 1, 10); step(2); instr <= enc_addi_x0(0, 0); step(1);

        instr <= enc_R(0, 4, 1, 5, 11); step(2); instr <= enc_addi_x0(0, 0); step(1);
        instr <= enc_R(32,4, 1, 5, 12); step(2); instr <= enc_addi_x0(0, 0); step(1);

        instr <= enc_R(0, 3, 1, 2, 13); step(2); instr <= enc_addi_x0(0, 0); step(1);
        assert to_integer(to_u32(regA_q)) = 0 severity error;

        instr <= enc_R(0, 3, 1, 3, 14); step(2); instr <= enc_addi_x0(0, 0); step(1);
        assert to_integer(to_u32(regA_q)) = 1 severity error;

        -- I-type
        instr <= enc_I(1, 15, 0, 7); step(2); instr <= enc_addi_x0(0, 0); step(1);
        assert to_integer(to_u32(regA_q)) = 12 severity error;

        instr <= enc_I(1, 16, 6, 3); step(2); instr <= enc_addi_x0(0, 0); step(1);
        assert to_integer(to_u32(regA_q)) = 7 severity error;

        instr <= enc_I(1, 17, 4, 10); step(2); instr <= enc_addi_x0(0, 0); step(1);
        assert to_integer(to_u32(regA_q)) = 15 severity error;

        instr <= enc_I(1, 18, 7, 14); step(2); instr <= enc_addi_x0(0, 0); step(1);
        assert to_integer(to_u32(regA_q)) = 4 severity error;

        instr <= enc_I_shift(2,19,1,0,1);  step(2); instr <= enc_addi_x0(0, 0); step(1);
        assert to_integer(to_u32(regA_q)) = 24 severity error;

        instr <= enc_I_shift(2,20,5,0,1);  step(2); instr <= enc_addi_x0(0, 0); step(1);
        assert to_integer(to_u32(regA_q)) = 6 severity error;

        instr <= enc_I_shift(4,21,5,32,1); step(2); instr <= enc_addi_x0(0, 0); step(1);
        assert to_integer(signed(regA_q)) = -4 severity error;

        instr <= enc_I(4,22,2,-16); step(2); instr <= enc_addi_x0(0, 0); step(1);
        assert to_integer(to_u32(regA_q)) = 0 severity error;

        instr <= enc_I(3,23,3,-1);  step(2); instr <= enc_addi_x0(0, 0); step(1);
        assert to_integer(to_u32(regA_q)) = 0 severity error;

        -- U-type
        instr <= enc_U(16#37#, 5, 16#12345#); step(2); instr <= enc_addi_x0(0, 0); step(1);
        assert to_u32(regA_q) = shift_left(to_u32(x"00012345"), 12) severity error;

        pc0 := to_u32(pc_q);
        instr <= enc_U(16#17#, 10, 16#00100#); step(2); instr <= enc_addi_x0(0, 0); step(1);
        expect := pc0 + to_unsigned(16#00100#,32) * 4096;
        assert to_u32(regA_q) = expect severity error;

        -- Branches
        pc0 := to_u32(pc_q);
        instr <= enc_B(1,1,0, 8); step(2); step(1);  -- BEQ taken, +8
        assert illegal='0' severity error;

        pc0 := to_u32(pc_q);
        instr <= enc_B(1,1,1, 8); step(3);          -- BNE not taken
        assert to_u32(pc_q) = pc0 + 4 severity error;

        -- Jumps
        pc0 := to_u32(pc_q);
        instr <= enc_J(6, 8); step(3);
        assert illegal='0' severity error;

        instr <= enc_I(1, 7, 0, 4); step(3);        -- JALR x7, x1, 4 (I-type target)
        assert illegal='0' severity error;

        -- Loads/Stores (decode-only with this datapath)
        instr <= enc_I_load(1, 7, 2, 12); step(1);  -- LW x7, 12(x1)
        assert illegal='0' severity error;
        instr <= enc_S(2, 1, 2, 8); step(1);        -- SW x2, 8(x1)
        assert illegal='0' severity error;

        -- Illegal
        instr <= (others => '0'); step(1);
        assert illegal='1' severity error;

        report "DONE";
        wait;
    end process;

end Behavioral;
