
----------------------------------------------------------------------------------
-- Company:
-- Engineer: Eyosi
--
-- Testbench: RISCV_Inst_Conn_tb_eyu_fixed
-- Purpose  : Integrated test of connector (decoder + datapath)
--            Uses ASSERT ... SEVERITY WARNING like the prof's TB.
--            Uses encoder helpers to avoid wrong hex encodings.
----------------------------------------------------------------------------------

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.NUMERIC_STD.ALL;

entity RISCV_Inst_Conn_tb_eyu_fixed is
end RISCV_Inst_Conn_tb_eyu_fixed;

architecture Behavioral of RISCV_Inst_Conn_tb_eyu_fixed is
  constant T : time := 10 ns;

  -- UUT (connector) ports
  signal eyu_clk     : std_logic := '0';
  signal eyu_reset   : std_logic := '1';
  signal eyu_instr   : std_logic_vector(31 downto 0) := (others => '0');
  signal eyu_pc_q    : std_logic_vector(31 downto 0);
  signal eyu_alu_y   : std_logic_vector(31 downto 0);
  signal eyosi_A_q   : std_logic_vector(31 downto 0);
  signal eyosi_B_q   : std_logic_vector(31 downto 0);
  signal eyu_bad     : std_logic;

  -- ===== Encoder helpers =====

  -- ADDI rd, x0, imm12  (seed regs)
  function enc_addi_x0(rd : natural; imm12 : integer) return std_logic_vector is
    variable v  : unsigned(31 downto 0) := (others => '0');
    variable ui : signed(11 downto 0);
  begin
    ui := to_signed(imm12, 12);
    v  := to_unsigned(16#13#, 32);                      -- 0010011
    v  := v + shift_left(to_unsigned(rd, 32), 7);
    v  := v + shift_left(to_unsigned(0, 32), 12);
    v  := v + shift_left(resize(unsigned(ui), 32), 20);
    return std_logic_vector(v);
  end function;

  -- read back a register without changing state: ADDI x0, rs1, 0
  function enc_addi_read(rs1 : natural) return std_logic_vector is
    variable v : unsigned(31 downto 0) := (others => '0');
  begin
    v := to_unsigned(16#13#, 32);
    v := v + shift_left(to_unsigned(rs1, 32), 15);
    return std_logic_vector(v);
  end function;

  -- Generic I-type ALU
  function enc_I(rs1, rd, funct3 : natural; imm12 : integer) return std_logic_vector is
    variable v  : unsigned(31 downto 0) := (others => '0');
    variable ui : signed(11 downto 0);
  begin
    ui := to_signed(imm12, 12);
    v  := to_unsigned(16#13#, 32);                      -- 0010011
    v  := v + shift_left(resize(unsigned(ui), 32), 20); -- imm[11:0]
    v  := v + shift_left(to_unsigned(rs1, 32), 15);
    v  := v + shift_left(to_unsigned(funct3, 32), 12);
    v  := v + shift_left(to_unsigned(rd, 32), 7);
    return std_logic_vector(v);
  end function;

  -- I-type shifts (SLLI/SRLI/SRAI)
  function enc_I_shift(rs1, rd, funct3, funct7, shamt : natural) return std_logic_vector is
    variable v   : unsigned(31 downto 0) := (others => '0');
    constant sh5 : natural := shamt mod 32;
  begin
    v := to_unsigned(16#13#, 32);                       -- 0010011
    v := v + shift_left(to_unsigned(funct7, 32), 25);
    v := v + shift_left(to_unsigned(sh5,   32), 20);
    v := v + shift_left(to_unsigned(rs1,   32), 15);
    v := v + shift_left(to_unsigned(funct3,32), 12);
    v := v + shift_left(to_unsigned(rd,    32), 7);
    return std_logic_vector(v);
  end function;

  -- R-type
  function enc_R(funct7, rs2, rs1, funct3, rd : natural) return std_logic_vector is
    variable v : unsigned(31 downto 0) := (others => '0');
  begin
    v := to_unsigned(16#33#, 32);                       -- 0110011
    v := v + shift_left(to_unsigned(funct7, 32), 25);
    v := v + shift_left(to_unsigned(rs2, 32), 20);
    v := v + shift_left(to_unsigned(rs1, 32), 15);
    v := v + shift_left(to_unsigned(funct3, 32), 12);
    v := v + shift_left(to_unsigned(rd, 32), 7);
    return std_logic_vector(v);
  end function;

  -- B-type (offset in bytes)
  function enc_B(rs2, rs1, funct3 : natural; offset_bytes : integer) return std_logic_vector is
    variable v  : unsigned(31 downto 0) := (others => '0');
    variable imm : integer := offset_bytes / 2;
    variable ui  : signed(12 downto 0);
  begin
    ui := to_signed(imm, 13);
    v  := to_unsigned(16#63#, 32);                      -- 1100011
    v  := v + shift_left(to_unsigned(to_integer(unsigned(std_logic_vector(ui(12 downto 12)))), 32), 31);
    v  := v + shift_left(to_unsigned(to_integer(unsigned(std_logic_vector(ui(10 downto 5)))), 32), 25);
    v  := v + shift_left(to_unsigned(rs2, 32), 20);
    v  := v + shift_left(to_unsigned(rs1, 32), 15);
    v  := v + shift_left(to_unsigned(funct3, 32), 12);
    v  := v + shift_left(to_unsigned(to_integer(unsigned(std_logic_vector(ui(4 downto 1)))), 32), 8);
    v  := v + shift_left(to_unsigned(to_integer(unsigned(std_logic_vector(ui(11 downto 11)))), 32), 7);
    return std_logic_vector(v);
  end function;

  -- J-type (offset in bytes)
  function enc_J(rd : natural; offset_bytes : integer) return std_logic_vector is
    variable v  : unsigned(31 downto 0) := (others => '0');
    variable imm : integer := offset_bytes / 2;
    variable ui  : signed(20 downto 0);
  begin
    ui := to_signed(imm, 21);
    v  := to_unsigned(16#6F#, 32);                      -- 1101111
    v  := v + shift_left(to_unsigned(to_integer(unsigned(std_logic_vector(ui(20 downto 20)))), 32), 31);
    v  := v + shift_left(to_unsigned(to_integer(unsigned(std_logic_vector(ui(10 downto 1)))), 32), 21);
    v  := v + shift_left(to_unsigned(to_integer(unsigned(std_logic_vector(ui(11 downto 11)))), 32), 20);
    v  := v + shift_left(to_unsigned(to_integer(unsigned(std_logic_vector(ui(19 downto 12)))), 32), 12);
    v  := v + shift_left(to_unsigned(rd, 32), 7);
    return std_logic_vector(v);
  end function;

  function to_u32(slv : std_logic_vector) return unsigned is
  begin
    return unsigned(slv);
  end function;

begin
  -- clock
  eyu_clk <= not eyu_clk after T/2;

  -- UUT
  UUT: entity work.connector
    port map (
      clk         => eyu_clk,
      reset       => eyu_reset,
      eyu         => eyu_instr,
      pc_q        => eyu_pc_q,
      alu_y       => eyu_alu_y,
      regA_q      => eyosi_A_q,
      regB_q      => eyosi_B_q,
      eyu_illegal => eyu_bad
    );

  -- ===================== STIMULUS =====================
  process
    variable pc0 : unsigned(31 downto 0);
  begin
    -- reset
    eyu_instr <= (others => '0');
    eyu_reset <= '1'; wait for 2*T;
    eyu_reset <= '0'; wait for 1*T;

    -- NOP (legal) + all-zeros (illegal)
    eyu_instr <= x"00000013"; wait for 5 ns;
    assert eyu_bad='0' report "NOP flagged illegal" severity warning;

    eyu_instr <= (others => '0'); wait for 5 ns;
    assert eyu_bad='1' report "All-zero opcode should be illegal" severity warning;

    ----------------------------------------------------------------
    -- Seed registers for later ALU checks
    ----------------------------------------------------------------
    eyu_instr <= enc_addi_x0(1, 5);  wait for 2*T;    -- x1 = 5
    eyu_instr <= enc_addi_x0(2, 12); wait for 2*T;    -- x2 = 12
    eyu_instr <= enc_addi_x0(3, -1); wait for 2*T;    -- x3 = 0xFFFF_FFFF
    eyu_instr <= enc_addi_x0(4, -8); wait for 2*T;    -- x4 = 0xFFFF_FFF8

    ----------------------------------------------------------------
    -- LUI x5,0x12345  -> 0x12345000
    ----------------------------------------------------------------
    eyu_instr <= x"123452B7"; wait for 2*T;
    eyu_instr <= enc_addi_read(5);   wait for 1*T;
    assert to_u32(eyosi_A_q)=to_unsigned(16#12345000#,32)
      report "LUI failed: x5 mismatch" severity warning;

    ----------------------------------------------------------------
    -- ADDI x15,x1,7 -> 12  (use encoder to avoid wrong hex)
    ----------------------------------------------------------------
    eyu_instr <= enc_I(1, 15, 0, 7); wait for 2*T;
    eyu_instr <= enc_addi_read(15);  wait for 1*T;
    assert to_u32(eyosi_A_q)=to_unsigned(12,32)
      report "ADDI x15 failed" severity warning;

    ----------------------------------------------------------------
    -- SLLI x19,x2,1 -> 24
    ----------------------------------------------------------------
    eyu_instr <= enc_I_shift(2, 19, 1, 0, 1); wait for 2*T;
    eyu_instr <= enc_addi_read(19);          wait for 1*T;
    assert to_u32(eyosi_A_q)=to_unsigned(24,32)
      report "SLLI x19 failed" severity warning;

    ----------------------------------------------------------------
    -- ADD x5,x1,x2 -> 17 ; SUB x6,x1,x2 -> -7
    ----------------------------------------------------------------
    eyu_instr <= enc_R(0, 2, 1, 0, 5); wait for 2*T;  -- ADD
    eyu_instr <= enc_addi_read(5);     wait for 1*T;
    assert to_u32(eyosi_A_q)=to_unsigned(17,32)
      report "ADD x5 failed" severity warning;

    eyu_instr <= enc_R(32, 2, 1, 0, 6); wait for 2*T; -- SUB
    eyu_instr <= enc_addi_read(6);      wait for 1*T;
    assert signed(eyosi_A_q)=to_signed(-7,32)
      report "SUB x6 failed" severity warning;

    ----------------------------------------------------------------
    -- AUIPC x10,0x00100: check writeback to x10 using PC before op
    ----------------------------------------------------------------
    pc0 := to_u32(eyu_pc_q);
    eyu_instr <= x"00100517"; wait for 2*T;            -- AUIPC
    eyu_instr <= enc_addi_read(10); wait for 1*T;
    assert to_u32(eyosi_A_q)=pc0 + shift_left(to_unsigned(16#00100#,32),12)
      report "AUIPC x10 failed" severity warning;

    ----------------------------------------------------------------
    -- BEQ x1,x1,+8 : PC should jump by +8
    ----------------------------------------------------------------
    pc0 := to_u32(eyu_pc_q);
    eyu_instr <= enc_B(1,1,0, 8); wait for 2*T;
    wait for 1*T;  -- allow PC load
    assert to_u32(eyu_pc_q)=pc0 + 8
      report "BEQ not taken (expected PC+8)" severity warning;

    ----------------------------------------------------------------
    -- JAL +8 : PC should jump by +8
    ----------------------------------------------------------------
    pc0 := to_u32(eyu_pc_q);
    eyu_instr <= enc_J(6, 8); wait for 3*T;
    assert to_u32(eyu_pc_q)=pc0 + 8
      report "JAL PC wrong (expected +8)" severity warning;

    ----------------------------------------------------------------
    -- JALR x7,x1,4 : PC should become (x1+4)&~1 = 8
    -- NOTE: If your PC.vhd doesn't clear bit0 on loads, this will fail.
    ----------------------------------------------------------------
    eyu_instr <= enc_I(1, 7, 0, 4); wait for 3*T;  -- JALR via encoder
    assert to_u32(eyu_pc_q)=to_unsigned(8,32)
      report "JALR PC wrong (expected 8 with LSB cleared)" severity warning;

    ----------------------------------------------------------------
    -- LOAD/STORE decode-only sanity: just ensure they're legal
    ----------------------------------------------------------------
    eyu_instr <= x"00C0A383"; wait for 1*T;            -- LW x7,12(x1)
    assert eyu_bad='0' report "LW flagged illegal" severity warning;

    eyu_instr <= x"0020A423"; wait for 1*T;            -- SW x2,8(x1)
    assert eyu_bad='0' report "SW flagged illegal" severity warning;

    report "TB finished" severity note;
    wait;
  end process;
end Behavioral;
