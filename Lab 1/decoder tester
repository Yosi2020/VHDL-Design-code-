
----------------------------------------------------------------------------------
-- Company:
-- Engineer: Eyosi
--
-- Testbench: RISCV_Inst_Conn_tb_eyu
-- Purpose  : Integrated test of connector (decoder + datapath) using
--            short hex instructions + ASSERT ... SEVERITY WARNING,
--            similar style to the professor's TB.
----------------------------------------------------------------------------------

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.NUMERIC_STD.ALL;

entity RISCV_Inst_Conn_tb_eyu is
end RISCV_Inst_Conn_tb_eyu;

architecture Behavioral of RISCV_Inst_Conn_tb_eyu is
  constant T : time := 10 ns;

  -- UUT (connector) ports
  signal eyu_clk     : std_logic := '0';
  signal eyu_reset   : std_logic := '1';
  signal eyu_instr   : std_logic_vector(31 downto 0) := (others => '0');
  signal eyu_pc_q    : std_logic_vector(31 downto 0);
  signal eyu_alu_y   : std_logic_vector(31 downto 0);
  signal eyosi_A_q   : std_logic_vector(31 downto 0);
  signal eyosi_B_q   : std_logic_vector(31 downto 0);
  signal eyu_bad     : std_logic;

  -- helper encoders for single-cycle stimulus
  function enc_addi_x0(rd : natural; imm12 : integer) return std_logic_vector is
    variable v  : unsigned(31 downto 0) := (others => '0');
    variable ui : signed(11 downto 0);
  begin
    ui := to_signed(imm12, 12);
    v  := to_unsigned(16#13#, 32);                      -- 0010011
    v  := v + shift_left(to_unsigned(rd, 32), 7);
    v  := v + shift_left(to_unsigned(0, 32), 12);
    v  := v + shift_left(resize(unsigned(ui), 32), 20);
    return std_logic_vector(v);
  end function;

  -- read back a register without changing state: ADDI x0, rs1, 0
  function enc_addi_read(rs1 : natural) return std_logic_vector is
    variable v : unsigned(31 downto 0) := (others => '0');
  begin
    v := to_unsigned(16#13#, 32);
    v := v + shift_left(to_unsigned(rs1, 32), 15);
    return std_logic_vector(v);
  end function;

  function to_u32(slv : std_logic_vector) return unsigned is
  begin
    return unsigned(slv);
  end function;

begin
  -- clock
  eyu_clk <= not eyu_clk after T/2;

  -- UUT
  UUT: entity work.connector
    port map (
      clk         => eyu_clk,
      reset       => eyu_reset,
      eyu         => eyu_instr,
      pc_q        => eyu_pc_q,
      alu_y       => eyu_alu_y,
      regA_q      => eyosi_A_q,
      regB_q      => eyosi_B_q,
      eyu_illegal => eyu_bad
    );

  -- ===================== STIMULUS =====================
  process
    variable pc0 : unsigned(31 downto 0);
  begin
    -- reset
    eyu_instr <= (others => '0');
    eyu_reset <= '1'; wait for 2*T;
    eyu_reset <= '0'; wait for 1*T;

    -- NOP (legal) + all-zeros (illegal)
    eyu_instr <= x"00000013"; wait for 5 ns;
    assert eyu_bad='0' report "NOP flagged illegal" severity warning;

    eyu_instr <= (others => '0'); wait for 5 ns;
    assert eyu_bad='1' report "All-zero opcode should be illegal" severity warning;

    ----------------------------------------------------------------
    -- Seed registers for later ALU checks
    ----------------------------------------------------------------
    eyu_instr <= enc_addi_x0(1, 5);  wait for 2*T;    -- x1 = 5
    eyu_instr <= enc_addi_x0(2, 12); wait for 2*T;    -- x2 = 12
    eyu_instr <= enc_addi_x0(3, -1); wait for 2*T;    -- x3 = 0xFFFF_FFFF
    eyu_instr <= enc_addi_x0(4, -8); wait for 2*T;    -- x4 = 0xFFFF_FFF8

    ----------------------------------------------------------------
    -- LUI x5,0x12345  -> 0x12345000
    ----------------------------------------------------------------
    eyu_instr <= x"123452B7"; wait for 2*T;
    eyu_instr <= enc_addi_read(5);   wait for 1*T;
    assert to_u32(eyosi_A_q)=to_unsigned(16#12345000#,32)
      report "LUI failed: x5 mismatch" severity warning;

    ----------------------------------------------------------------
    -- ADDI x15,x1,7 -> 12
    ----------------------------------------------------------------
    eyu_instr <= x"00708093"; wait for 2*T;            -- enc_I(1,15,0,7) in hex
    eyu_instr <= enc_addi_read(15); wait for 1*T;
    assert to_u32(eyosi_A_q)=to_unsigned(12,32)
      report "ADDI x15 failed" severity warning;

    ----------------------------------------------------------------
    -- SLLI x19,x2,1 -> 24
    ----------------------------------------------------------------
    eyu_instr <= x"00111193"; wait for 2*T;
    eyu_instr <= enc_addi_read(19); wait for 1*T;
    assert to_u32(eyosi_A_q)=to_unsigned(24,32)
      report "SLLI x19 failed" severity warning;

    ----------------------------------------------------------------
    -- ADD x5,x1,x2 -> 17 ; SUB x6,x1,x2 -> -7
    ----------------------------------------------------------------
    eyu_instr <= x"002082B3"; wait for 2*T;            -- ADD x5,x1,x2
    eyu_instr <= enc_addi_read(5);  wait for 1*T;
    assert to_u32(eyosi_A_q)=to_unsigned(17,32)
      report "ADD x5 failed" severity warning;

    eyu_instr <= x"40208333"; wait for 2*T;            -- SUB x6,x1,x2
    eyu_instr <= enc_addi_read(6);  wait for 1*T;
    assert signed(eyosi_A_q)=to_signed(-7,32)
      report "SUB x6 failed" severity warning;

    ----------------------------------------------------------------
    -- AUIPC x10,0x00100: check writeback to x10 using PC before op
    ----------------------------------------------------------------
    pc0 := to_u32(eyu_pc_q);
    eyu_instr <= x"00100517"; wait for 2*T;            -- AUIPC
    eyu_instr <= enc_addi_read(10); wait for 1*T;
    assert to_u32(eyosi_A_q)=pc0 + shift_left(to_unsigned(16#00100#,32),12)
      report "AUIPC x10 failed" severity warning;

    ----------------------------------------------------------------
    -- BEQ x1,x1,+8 : PC should jump by +8
    ----------------------------------------------------------------
    pc0 := to_u32(eyu_pc_q);
    eyu_instr <= x"00108463"; wait for 2*T;            -- BEQ +8
    wait for 1*T;  -- allow PC load
    assert to_u32(eyu_pc_q)=pc0 + 8
      report "BEQ not taken (expected PC+8)" severity warning;

    ----------------------------------------------------------------
    -- JAL +8 : PC should jump by +8
    ----------------------------------------------------------------
    pc0 := to_u32(eyu_pc_q);
    eyu_instr <= x"0080036F"; wait for 3*T;
    assert to_u32(eyu_pc_q)=pc0 + 8
      report "JAL PC wrong (expected +8)" severity warning;

    ----------------------------------------------------------------
    -- JALR x7,x1,4 : PC should become (x1+4)&~1 = 8
    ----------------------------------------------------------------
    eyu_instr <= x"004083E7"; wait for 3*T;
    assert to_u32(eyu_pc_q)=to_unsigned(8,32)
      report "JALR PC wrong (expected 8 with LSB cleared)" severity warning;

    ----------------------------------------------------------------
    -- LOAD/STORE decode-only sanity: check ALU forms address = rs1 + imm
    ----------------------------------------------------------------
    eyu_instr <= x"00C0A383"; wait for 1*T;            -- LW x7,12(x1)
    assert eyu_bad='0' report "LW flagged illegal" severity warning;

    eyu_instr <= x"0020A423"; wait for 1*T;            -- SW x2,8(x1)
    assert eyu_bad='0' report "SW flagged illegal" severity warning;

    report "TB finished" severity note;
    wait;
  end process;
end Behavioral;
