
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.NUMERIC_STD.ALL;

entity TESTBENCH is
end TESTBENCH;

architecture Behavioral of TESTBENCH is
    constant CLK_PERIOD : time := 10 ns;

    signal clk       : std_logic := '0';
    signal reset     : std_logic := '1';
    signal instr     : std_logic_vector(31 downto 0) := (others => '0');
    signal pc_q      : std_logic_vector(31 downto 0);
    signal alu_y     : std_logic_vector(31 downto 0);
    signal regA_q    : std_logic_vector(31 downto 0);
    signal regB_q    : std_logic_vector(31 downto 0);
    signal illegal   : std_logic;

    -- small helper: advance n cycles
    procedure step(n : natural := 1) is
    begin
        for i in 1 to n loop
            wait until rising_edge(clk);
        end loop;
    end procedure;

    -- Form "ADDI x0, rs1, 0" so we can read back rs1 on regA_q
    function addi_read(rs1 : natural) return std_logic_vector is
        variable v : unsigned(31 downto 0) := (others => '0');
    begin
        -- opcode 0010011 at [6:0]
        v := to_unsigned(16#13#, 32);
        -- rs1 field at [19:15]
        v := v + shift_left(to_unsigned(rs1, 32), 15);
        -- funct3=000, rd=0, imm=0 -> already zero
        return std_logic_vector(v);
    end function;

    -- A few real RV32I encodings
    constant LUI_x5_12345   : std_logic_vector(31 downto 0) := x"123452B7";
    constant AUIPC_x10_0100 : std_logic_vector(31 downto 0) := x"00100517";
    constant ADDI_x1_x0_5   : std_logic_vector(31 downto 0) := x"00500093";
    constant ORI_x2_x1_0F   : std_logic_vector(31 downto 0) := x"00F0E113";
    constant SLLI_x3_x2_1   : std_logic_vector(31 downto 0) := x"00111193";
    constant ADD_x4_x1_x2   : std_logic_vector(31 downto 0) := x"00208233";
    constant SUB_x5_x1_x2   : std_logic_vector(31 downto 0) := x"402082B3";
    constant BEQ_x1_x1_p8   : std_logic_vector(31 downto 0) := x"00108463";
    constant BNE_x1_x0_p12  : std_logic_vector(31 downto 0) := x"00009663";
    constant JAL_x6_p8      : std_logic_vector(31 downto 0) := x"0080036F";
    constant JALR_x7_x1_4   : std_logic_vector(31 downto 0) := x"004083E7";
    constant LW_x7_12_x1    : std_logic_vector(31 downto 0) := x"00C0A383";
    constant SW_x2_8_x1     : std_logic_vector(31 downto 0) := x"0020A423";

begin
    -- clock
    clk <= not clk after CLK_PERIOD/2;

    -- unit under test
    UUT: entity work.connector
        port map (
            clk         => clk,
            reset       => reset,
            eyu         => instr,
            pc_q        => pc_q,
            alu_y       => alu_y,
            regA_q      => regA_q,
            regB_q      => regB_q,
            eyu_illegal => illegal
        );

    -- sequence
    process
        variable pc0 : unsigned(31 downto 0);
    begin
        -- reset
        instr <= (others => '0');
        reset <= '1';
        step(2);
        reset <= '0';
        step(1);

        -- LUI
        report "LUI x5, 0x12345";
        instr <= LUI_x5_12345; step(2);
        instr <= addi_read(5); step(1); -- read x5
        assert illegal = '0' severity error;

        -- ADDI
        report "ADDI x1, x0, 5";
        instr <= ADDI_x1_x0_5; step(2);
        instr <= addi_read(1); step(1);
        assert illegal = '0' severity error;

        -- ORI
        report "ORI x2, x1, 0x0F";
        instr <= ORI_x2_x1_0F; step(2);
        instr <= addi_read(2); step(1);
        assert illegal = '0' severity error;

        -- SLLI
        report "SLLI x3, x2, 1";
        instr <= SLLI_x3_x2_1; step(2);
        instr <= addi_read(3); step(1);

        -- ADD
        report "ADD x4, x1, x2";
        instr <= ADD_x4_x1_x2; step(2);
        instr <= addi_read(4); step(1);

        -- SUB
        report "SUB x5, x1, x2";
        instr <= SUB_x5_x1_x2; step(2);
        instr <= addi_read(5); step(1);

        -- BEQ (taken)
        report "BEQ x1, x1, +8";
        pc0 := unsigned(pc_q);
        instr <= BEQ_x1_x1_p8; step(3);
        report "PC moved from " & integer'image(to_integer(pc0)) &
               " to " & integer'image(to_integer(unsigned(pc_q)));

        -- JAL
        report "JAL +8";
        pc0 := unsigned(pc_q);
        instr <= JAL_x6_p8; step(3);
        report "PC after JAL = " & integer'image(to_integer(unsigned(pc_q)));

        -- JALR
        report "JALR x7, x1, 4";
        pc0 := unsigned(pc_q);
        instr <= JALR_x7_x1_4; step(3);
        report "PC after JALR = " & integer'image(to_integer(unsigned(pc_q)));

        -- LW / SW (decode only in this datapath)
        instr <= LW_x7_12_x1; step(1);
        instr <= SW_x2_8_x1;  step(1);

        report "DONE";
        wait;
    end process;

end Behavioral;
