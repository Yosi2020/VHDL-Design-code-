
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity tb_cpu_top is
end entity;

architecture sim of tb_cpu_top is
  constant T : time := 10 ns;

  signal clk     : std_logic := '0';
  signal reset   : std_logic := '1';
  signal instr   : std_logic_vector(31 downto 0) := (others => '0');
  signal pc_q    : std_logic_vector(31 downto 0);
  signal alu_y   : std_logic_vector(31 downto 0);
  signal regA_q  : std_logic_vector(31 downto 0);
  signal regB_q  : std_logic_vector(31 downto 0);
  signal illegal : std_logic;

  -- === Helper subprograms ===
  procedure tick(n : natural := 1) is
  begin
    for i in 1 to n loop
      wait until rising_edge(clk);
    end loop;
  end procedure;

  -- Encode "ADDI x0, rs1, 0" so we can read back rs1 through regA_q safely.
  function addi_read(rs1 : natural) return std_logic_vector is
    variable v : unsigned(31 downto 0) := (others => '0');
  begin
    -- opcode 0x13 at [6:0]
    v := to_unsigned(16#13#,32);
    -- rs1 at [19:15]
    v := v + shift_left(to_unsigned(rs1,32), 15);
    -- funct3=000, rd=0, imm=0  --> all zero additions
    return std_logic_vector(v);
  end function;

  -- === Handy named instruction constants (legal encodings) ===
  constant LUI_x5_12345   : std_logic_vector(31 downto 0) := x"123452B7";
  constant AUIPC_x10_0100 : std_logic_vector(31 downto 0) := x"00100517";
  constant ADDI_x1_x0_5   : std_logic_vector(31 downto 0) := x"00500093";
  constant ORI_x2_x1_0F   : std_logic_vector(31 downto 0) := x"00F0E113";
  constant SLLI_x3_x2_1   : std_logic_vector(31 downto 0) := x"00111193";
  constant ADD_x4_x1_x2   : std_logic_vector(31 downto 0) := x"00208233";
  constant SUB_x5_x1_x2   : std_logic_vector(31 downto 0) := x"402082B3";
  constant BEQ_x1_x1_p8   : std_logic_vector(31 downto 0) := x"00108463";
  constant BNE_x1_x0_p12  : std_logic_vector(31 downto 0) := x"00009663";
  constant JAL_x6_p8      : std_logic_vector(31 downto 0) := x"0080036F";
  constant JALR_x7_x1_4   : std_logic_vector(31 downto 0) := x"004083E7";
  constant LW_x7_12_x1    : std_logic_vector(31 downto 0) := x"00C0A383";
  constant SW_x2_8_x1     : std_logic_vector(31 downto 0) := x"0020A423";

begin
  -- clock
  clk <= not clk after T/2;

  -- UUT
  UUT: entity work.connector
    port map (
      clk     => clk,
      reset   => reset,
      eyu   => instr,
      pc_q    => pc_q,
      alu_y   => alu_y,
      regA_q  => regA_q,
      regB_q  => regB_q,
      eyu_illegal => illegal
    );

  -- Stimulus
  stim: process
    variable pc_before : unsigned(31 downto 0);
  begin
    -- Reset
    instr <= (others => '0');
    reset <= '1';
    tick(2);
    reset <= '0';
    tick(1);

    report "=== LUI x5, 0x12345 ===";
    instr <= LUI_x5_12345; tick(2);
    instr <= addi_read(5); tick(1);
    report "regA_q (x5) = " & integer'image(to_integer(unsigned(regA_q)));
    assert illegal='0' report "LUI flagged illegal" severity error;

    report "=== ADDI x1, x0, 5 ===";
    instr <= ADDI_x1_x0_5; tick(2);
    instr <= addi_read(1); tick(1);
    report "regA_q (x1) should be 5 -> " & integer'image(to_integer(unsigned(regA_q)));
    assert illegal='0' report "ADDI flagged illegal" severity error;

    report "=== ORI x2, x1, 0x0F ===";
    instr <= ORI_x2_x1_0F; tick(2);
    instr <= addi_read(2); tick(1);
    report "regA_q (x2) = " & integer'image(to_integer(unsigned(regA_q)));
    assert illegal='0' report "ORI flagged illegal" severity error;

    report "=== SLLI x3, x2, 1 ===";
    instr <= SLLI_x3_x2_1; tick(2);
    instr <= addi_read(3); tick(1);
    report "regA_q (x3) = " & integer'image(to_integer(unsigned(regA_q)));

    report "=== ADD x4, x1, x2 ===";
    instr <= ADD_x4_x1_x2; tick(2);
    instr <= addi_read(4); tick(1);
    report "regA_q (x4) = " & integer'image(to_integer(unsigned(regA_q)));

    report "=== SUB x5, x1, x2 ===";
    instr <= SUB_x5_x1_x2; tick(2);
    instr <= addi_read(5); tick(1);
    report "regA_q (x5) = " & integer'image(to_integer(unsigned(regA_q)));

    report "=== BEQ x1, x1, +8 (taken) ===";
    pc_before := unsigned(pc_q);
    instr <= BEQ_x1_x1_p8; tick(3);  -- allow branch pipeline
    report "PC before=" & integer'image(to_integer(pc_before)) &
           " after="   & integer'image(to_integer(unsigned(pc_q)));
    assert illegal='0' report "BEQ flagged illegal" severity error;

    report "=== JAL x6, +8 ===";
    pc_before := unsigned(pc_q);
    instr <= JAL_x6_p8; tick(3);
    report "PC jumped from " & integer'image(to_integer(pc_before)) &
           " to " & integer'image(to_integer(unsigned(pc_q)));
    assert illegal='0' report "JAL flagged illegal" severity error;

    report "=== JALR x7, x1, 4 ===";
    pc_before := unsigned(pc_q);
    instr <= JALR_x7_x1_4; tick(3);
    report "PC after JALR = " & integer'image(to_integer(unsigned(pc_q)));
    assert illegal='0' report "JALR flagged illegal" severity error;

    report "=== LW/SW (decode-only) ===";
    instr <= LW_x7_12_x1; tick(1);
    assert illegal='0' report "LW flagged illegal" severity error;
    instr <= SW_x2_8_x1;  tick(1);
    assert illegal='0' report "SW flagged illegal" severity error;

    report "=== TEST COMPLETE ===";
    wait;
  end process;
end architecture;
