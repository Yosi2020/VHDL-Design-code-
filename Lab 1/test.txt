-- tb_datapath_all.vhd
-- self-checking testbench for your data_path top (pc, alu, branch, register)
-- includes: section tags for waves, proper BRcond handling, 32-bit buses

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

-- brings in control_t_array, flag_array, and cw indices (immBsel, pcDsel, pcAsel, pcle, pcie, dle, isBR, BR0..BR2)
use work.my_package.all;

entity datapath_testbench is
end datapath_testbench;

architecture tb of datapath_testbench is
  
  signal imm : std_logic_vector(31 downto 0) := (others => '0');
  signal asel : std_logic_vector(4 downto 0)  := (others => '0');
  signal bsel : std_logic_vector(4 downto 0)  := (others => '0');
  signal alufunc : std_logic_vector(3 downto 0)  := (others => '0');
  signal dsel : std_logic_vector(4 downto 0)  := (others => '0');

  signal memin : std_logic_vector(31 downto 0) := (others => '0');
  signal clk : std_logic := '0';
  signal rst : std_logic := '1';

  signal memout : std_logic_vector(31 downto 0);
  signal addr : std_logic_vector(31 downto 0);
  signal flags : flag_array;
  signal cw : control_t_array;

  signal t_add, t_sub, t_and, t_or, t_xor,
         t_sll, t_srl, t_sra,
         t_slt, t_sltu,
         t_pcinc,
         t_beq, t_bne, t_blt, t_bge, t_bltu, t_bgeu,
         t_jal : std_logic := '0';

  -- alu ops
  constant alu_add : std_logic_vector(3 downto 0) := "0001";
  constant alu_sub : std_logic_vector(3 downto 0) := "0010";
  constant alu_or : std_logic_vector(3 downto 0) := "0011";
  constant alu_xor : std_logic_vector(3 downto 0) := "0100";
  constant alu_and : std_logic_vector(3 downto 0) := "0101";
  constant alu_slt : std_logic_vector(3 downto 0) := "0110";
  constant alu_sltu : std_logic_vector(3 downto 0) := "0111";
  constant alu_sll : std_logic_vector(3 downto 0) := "1000";
  constant alu_srl : std_logic_vector(3 downto 0) := "1001";
  constant alu_sra : std_logic_vector(3 downto 0) := "1010";

  -- branch conds
  constant br_beq : std_logic_vector(2 downto 0) := "000";
  constant br_bne : std_logic_vector(2 downto 0) := "001";
  constant br_blt : std_logic_vector(2 downto 0) := "010"; -- signed  <
  constant br_bge : std_logic_vector(2 downto 0) := "011"; -- signed  >=
  constant br_bltu : std_logic_vector(2 downto 0) := "110"; -- unsigned <
  constant br_bgeu : std_logic_vector(2 downto 0) := "111"; -- unsigned >=

  -- flag bit positions (edit if your flag_array order differs)
  constant f_z : natural := 0; -- zero
  constant f_n : natural := 1; -- negative
  constant f_c : natural := 2; -- carry
  constant f_v : natural := 3; -- overflow

  -- register ids (5-bit)
  constant x0 : std_logic_vector(4 downto 0) := "00000";
  constant x1 : std_logic_vector(4 downto 0) := "00001";
  constant x2 : std_logic_vector(4 downto 0) := "00010";
  constant x3 : std_logic_vector(4 downto 0) := "00011";
  constant x4 : std_logic_vector(4 downto 0) := "00100";
  constant x5 : std_logic_vector(4 downto 0) := "00101";
  constant x6 : std_logic_vector(4 downto 0) := "00110";
  constant x7 : std_logic_vector(4 downto 0) := "00111";
  constant x8 : std_logic_vector(4 downto 0) := "01000";
  constant x9 : std_logic_vector(4 downto 0) := "01001";
  constant x10 : std_logic_vector(4 downto 0) := "01010";
  constant x11 : std_logic_vector(4 downto 0) := "01011";
  constant x12 : std_logic_vector(4 downto 0) := "01100";
  constant x13 : std_logic_vector(4 downto 0) := "01101";
  constant x14 : std_logic_vector(4 downto 0) := "01110";
  constant x15 : std_logic_vector(4 downto 0) := "01111";

begin

  clk <= not clk after 5 ns;  -- 100 MHz

  uut: entity work.data_path
    port map (
      cw       => cw,
      imm      => imm,
      asel     => asel,
      bsel     => bsel,
      alufunc  => alufunc,
      dsel     => dsel,
      memin    => memin,
      clk      => clk,
      rst      => rst,
      memout   => memout,
      addr     => addr,
      flags    => flags
    );
  
-- clock start and reset
  procedure step is
  begin
    wait until rising_edge(clk);
  end procedure;

  procedure cw_clear is
  begin
    cw <= (others => '0');
    wait for 1 ns;
  end procedure;

  -- the BRcond is 2-0 so we have like BR1, BR2, BR3
  procedure set_br(cond : std_logic_vector(2 downto 0)) is
  begin
    cw(BR0) <= cond(0);
    cw(BR1) <= cond(1);
    cw(BR2) <= cond(2);
  end procedure;

  procedure start(sig : inout std_logic) is begin sig <= '1'; wait for 1 ns; end;
  procedure stop (sig : inout std_logic) is begin sig <= '0'; wait for 1 ns; end;

  -- write: rd := imm   via A=0, B=imm, D<=ALU
  procedure wr_imm (rd : in std_logic_vector(4 downto 0);
                    v  : in std_logic_vector(31 downto 0)) is
  begin
    asel     <= x0;
    bsel     <= x0;          -- ignored when immBsel='1'
    imm      <= v;
    alufunc  <= alu_add;     -- 0 + imm
    cw_clear;
    cw(immBsel) <= '1';      -- B <= IMM
    cw(pcDsel)  <= '0';      -- Dbus <= ALU
    dsel        <= rd;
    cw(dle)     <= '1';
    step;
    cw(dle)     <= '0';
  end procedure;

  -- select ALU sources quickly
  procedure alu_src (use_pc_a, use_imm_b : in std_logic) is
  begin
    cw(pcAsel)  <= use_pc_a;   -- A <= PC when '1', else A <= reg(asel)
    cw(immBsel) <= use_imm_b;  -- B <= IMM when '1', else B <= reg(bsel)
  end procedure;

  -- jal-like: rd := PC   and   PC <- PC + IMM
  procedure do_jal (rd : in std_logic_vector(4 downto 0);
                    off: in std_logic_vector(31 downto 0)) is
  begin
    imm      <= off;
    alufunc  <= alu_add;
    cw_clear;
    alu_src('1','1');         -- A=PC, B=IMM
    cw(pcDsel) <= '1';        -- write-back PC to rd
    dsel       <= rd;
    cw(dle)    <= '1';
    cw(pcle)   <= '1';        -- PC <- ALU
    step;
    cw(dle)    <= '0';
    cw(pcle)   <= '0';
  end procedure;

  --------------------------------------------------------------------------
  -- stimulus
  --------------------------------------------------------------------------
  stim: process
    variable pc_before : std_logic_vector(31 downto 0);
  begin
    -- RESET
    cw_clear;
    rst <= '1'; step; step;
    rst <= '0'; step;
    assert addr = (others => '0') report "pc not zero after reset" severity failure;

    -- LOAD X1=5, X2=3
    wr_imm(x1, x"00000005");
    wr_imm(x2, x"00000003");

    -- ADD
    start(t_add);
    asel <= x1; bsel <= x2; alufunc <= alu_add;
    cw_clear; cw(pcDsel) <= '0'; dsel <= x3; cw(dle) <= '1'; step; cw(dle) <= '0';
    assert flags(f_z)='0' and flags(f_n)='0' report "add 5+3 flags unexpected" severity failure;
    stop(t_add);

    -- SUB
    start(t_sub);
    asel <= x1; bsel <= x2; alufunc <= alu_sub;
    cw_clear; cw(pcDsel) <= '0'; dsel <= x4; cw(dle) <= '1'; step; cw(dle) <= '0';
    assert flags(f_z)='0' and flags(f_n)='0' report "sub 5-3 flags unexpected" severity failure;
    stop(t_sub);

    -- ZERO (x1-x1)
    start(t_and); -- use tag slot just to stack; this block is zero-test
    asel <= x1; bsel <= x1; alufunc <= alu_sub;
    cw_clear; cw(pcDsel) <= '0'; dsel <= x5; cw(dle) <= '1'; step; cw(dle) <= '0';
    assert flags(f_z)='1' report "x1-x1 must set zero flag" severity failure;
    stop(t_and);

    -- AND / OR / XOR (sanity via flags)
    start(t_or);
    asel <= x1; bsel <= x2;
    alufunc <= alu_and; cw_clear; cw(pcDsel) <= '0'; dsel <= x6; cw(dle) <= '1'; step; cw(dle) <= '0';
    alufunc <= alu_or ; cw_clear; cw(pcDsel) <= '0'; dsel <= x6; cw(dle) <= '1'; step; cw(dle) <= '0';
    alufunc <= alu_xor; cw_clear; cw(pcDsel) <= '0'; dsel <= x6; cw(dle) <= '1'; step; cw(dle) <= '0';
    assert flags(f_z)='0' report "logic ops produced zero unexpectedly" severity note;
    stop(t_or);

    -- SHIFTS (use negative for SRL/SRA difference)
    wr_imm(x8,  x"FFFF_FF80");  -- -128
    wr_imm(x9,  x"0000_0004");  -- shamt=4

    start(t_sll);
    asel <= x8; bsel <= x9; alufunc <= alu_sll;
    cw_clear; cw(pcDsel) <= '0'; dsel <= x10; cw(dle) <= '1'; step; cw(dle) <= '0';
    stop(t_sll);

    start(t_srl);
    asel <= x8; bsel <= x9; alufunc <= alu_srl;
    cw_clear; cw(pcDsel) <= '0'; dsel <= x11; cw(dle) <= '1'; step; cw(dle) <= '0';
    assert flags(f_n)='0' report "srl should zero-fill (not negative)" severity failure;
    stop(t_srl);

    start(t_sra);
    asel <= x8; bsel <= x9; alufunc <= alu_sra;
    cw_clear; cw(pcDsel) <= '0'; dsel <= x12; cw(dle) <= '1'; step; cw(dle) <= '0';
    assert flags(f_n)='1' report "sra should sign-extend (negative)" severity failure;
    stop(t_sra);

    -- SLT / SLTU with -4 vs +2
    wr_imm(x13, x"FFFF_FFFC");  -- -4
    wr_imm(x14, x"00000002");   -- +2

    start(t_slt);
    asel <= x13; bsel <= x14; alufunc <= alu_slt;
    cw_clear; cw(pcDsel) <= '0'; dsel <= x15; cw(dle) <= '1'; step; cw(dle) <= '0';
    assert flags(f_z)='0' report "slt (-4 < 2) should be non-zero" severity note;
    stop(t_slt);

    start(t_sltu);
    asel <= x13; bsel <= x14; alufunc <= alu_sltu;
    cw_clear; cw(pcDsel) <= '0'; dsel <= x15; cw(dle) <= '1'; step; cw(dle) <= '0';
    assert flags(f_z)='1' report "sltu (0xFFFF_FFFC < 2) should be false" severity note;
    stop(t_sltu);

    -- PC +4
    start(t_pcinc);
    pc_before := addr;
    cw_clear; cw(pcie) <= '1'; step; cw(pcie) <= '0';
    assert unsigned(addr) = unsigned(pc_before) + 4 report "pc increment (+4) failed" severity failure;
    stop(t_pcinc);

    -- BRANCH TARGET via ALU = PC + IMM
    imm     <= x"00000010";        -- +16
    alufunc <= alu_add;

    -- BEQ (taken, A==B)
    start(t_beq);
    pc_before := addr;
    cw_clear; alu_src('1','1');    -- A=PC, B=IMM
    asel <= x1; bsel <= x1;
    set_br(br_beq); cw(isBR) <= '1'; step; cw(isBR) <= '0';
    assert unsigned(addr) = unsigned(pc_before) + 16 report "beq taken: pc mismatch" severity failure;
    stop(t_beq);

    -- BNE (not taken, A==B)
    start(t_bne);
    pc_before := addr;
    cw_clear; alu_src('1','1'); asel <= x1; bsel <= x1;
    set_br(br_bne); cw(isBR) <= '1'; step; cw(isBR) <= '0';
    assert addr = pc_before report "bne not-taken: pc changed" severity failure;
    stop(t_bne);

    -- BLT (signed) taken: -4 < 2
    start(t_blt);
    pc_before := addr;
    cw_clear; alu_src('1','1'); asel <= x13; bsel <= x14;
    set_br(br_blt); cw(isBR) <= '1'; step; cw(isBR) <= '0';
    assert unsigned(addr) = unsigned(pc_before) + 16 report "blt taken: pc not +16" severity failure;
    stop(t_blt);

    -- BGE (signed) not taken: -4 >= 2 is false
    start(t_bge);
    pc_before := addr;
    cw_clear; alu_src('1','1'); asel <= x13; bsel <= x14;
    set_br(br_bge); cw(isBR) <= '1'; step; cw(isBR) <= '0';
    assert addr = pc_before report "bge not-taken: pc changed" severity failure;
    stop(t_bge);

    -- BLTU (unsigned) not taken: 0xFFFF_FFFC < 2 is false
    start(t_bltu);
    pc_before := addr;
    cw_clear; alu_src('1','1'); asel <= x13; bsel <= x14;
    set_br(br_bltu); cw(isBR) <= '1'; step; cw(isBR) <= '0';
    assert addr = pc_before report "bltu not-taken: pc changed" severity failure;
    stop(t_bltu);

    -- BGEU (unsigned) taken: 0xFFFF_FFFC >= 2 true
    start(t_bgeu);
    pc_before := addr;
    cw_clear; alu_src('1','1'); asel <= x13; bsel <= x14;
    set_br(br_bgeu); cw(isBR) <= '1'; step; cw(isBR) <= '0';
    assert unsigned(addr) = unsigned(pc_before) + 16 report "bgeu taken: pc not +16" severity failure;
    stop(t_bgeu);

    -- JAL-like
    start(t_jal);
    pc_before := addr;
    do_jal(x8, x"00000020");
    assert unsigned(addr) = unsigned(pc_before) + 32 report "jal-like (+32) pc wrong" severity failure;
    stop(t_jal);

    wait;
  end process;

end architecture;
